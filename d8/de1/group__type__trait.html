<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: Type Traits</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../$standoxy.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">4.0.1</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d8/de1/group__type__trait.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Type Traits</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The type traits in Stan math are a mix of custom traits for detecting value and container types of <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrices, standard vectors, standard complex numbers, and backports of C++17 traits. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dcd/classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00_01fvar_3_01_dx_01_4_01_4.html">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, fvar&lt; Dx &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class builds partial derivatives with respect to a set of operands.  <a href="../../d7/dcd/classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00_01fvar_3_01_dx_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dfd/structstan_1_1is__constant_3_01_t_00_01require__all__kernel__expressions__and__none__scalar__t_3_01_t_01_4_01_4.html">stan::is_constant&lt; T, require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value and sets it to true if the type of the elements in the provided matrix_cl is constant, false otherwise.  <a href="../../d1/dfd/structstan_1_1is__constant_3_01_t_00_01require__all__kernel__expressions__and__none__scalar__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd1/classstan_1_1math_1_1internal_1_1ops__partials__edge.html">stan::math::internal::ops_partials_edge&lt; ViewElt, Op, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An edge holds both the operands and its associated partial derivatives.  <a href="../../d5/dd1/classstan_1_1math_1_1internal_1_1ops__partials__edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dd1/classstan_1_1math_1_1operands__and__partials.html">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, T_return_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template builds partial derivatives with respect to a set of operands.  <a href="../../da/dd1/classstan_1_1math_1_1operands__and__partials.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d71/classstan_1_1math_1_1internal_1_1ops__partials__edge_3_01_view_elt_00_01_op_00_01require__eigen_d9d920bd1e9dec9fcf10a021ac32e096.html">stan::math::internal::ops_partials_edge&lt; ViewElt, Op, require_eigen_st&lt; std::is_arithmetic, Op &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class will be used for both multivariate (nested container) <a class="el" href="../../da/dd1/classstan_1_1math_1_1operands__and__partials.html" title="This template builds partial derivatives with respect to a set of operands. ">operands_and_partials</a> edges as well as for the univariate case.  <a href="../../de/d71/classstan_1_1math_1_1internal_1_1ops__partials__edge_3_01_view_elt_00_01_op_00_01require__eigen_d9d920bd1e9dec9fcf10a021ac32e096.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d9c/classstan_1_1math_1_1internal_1_1ops__partials__edge_3_01_view_elt_00_01std_1_1vector_3_01_eigen36b41bb77171f91a743b22e45c631572.html">stan::math::internal::ops_partials_edge&lt; ViewElt, std::vector&lt; Eigen::Matrix&lt; Op, R, C &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d1c/classstan_1_1math_1_1internal_1_1ops__partials__edge_3_01_view_elt_00_01std_1_1vector_3_01std_1_1vector_3_01_op_01_4_01_4_01_4.html">stan::math::internal::ops_partials_edge&lt; ViewElt, std::vector&lt; std::vector&lt; Op &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dbb/structstan_1_1math_1_1ad__promotable.html">stan::math::ad_promotable&lt; From, To, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the type From can be converted to To using implicit conversions, or both From and To are possibly cv-qualified void), provides the member constant value equal to true.  <a href="../../da/dbb/structstan_1_1math_1_1ad__promotable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d4/d76/structstan_1_1math_1_1append__return__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d4/d76/structstan_1_1math_1_1append__return__type">stan::math::append_return_type&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:d4/d76/structstan_1_1math_1_1append__return__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template metaprogram is used to compute the return type for append_array.  <a href="../../d8/de1/group__type__trait.html#d4/d76/structstan_1_1math_1_1append__return__type">More...</a><br /></td></tr>
<tr class="separator:d4/d76/structstan_1_1math_1_1append__return__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d4/dff/structstan_1_1math_1_1append__return__type_3_01int_00_01int_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d4/dff/structstan_1_1math_1_1append__return__type_3_01int_00_01int_01_4">stan::math::append_return_type&lt; int, int &gt;</a></td></tr>
<tr class="memdesc:d4/dff/structstan_1_1math_1_1append__return__type_3_01int_00_01int_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template metaprogram is used to compute the return type for append_array.  <a href="../../d8/de1/group__type__trait.html#d4/dff/structstan_1_1math_1_1append__return__type_3_01int_00_01int_01_4">More...</a><br /></td></tr>
<tr class="separator:d4/dff/structstan_1_1math_1_1append__return__type_3_01int_00_01int_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d9/dfd/structstan_1_1math_1_1append__return__type_3_01_eigen_1_1_matrix_3_01_t1_00_01_r_00_01_c_01_4_0055a8b04836654f8c0781baa8c862db5f"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d9/dfd/structstan_1_1math_1_1append__return__type_3_01_eigen_1_1_matrix_3_01_t1_00_01_r_00_01_c_01_4_0055a8b04836654f8c0781baa8c862db5f">stan::math::append_return_type&lt; Eigen::Matrix&lt; T1, R, C &gt;, Eigen::Matrix&lt; T2, R, C &gt; &gt;</a></td></tr>
<tr class="memdesc:d9/dfd/structstan_1_1math_1_1append__return__type_3_01_eigen_1_1_matrix_3_01_t1_00_01_r_00_01_c_01_4_0055a8b04836654f8c0781baa8c862db5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template metaprogram is used to compute the return type for append_array.  <a href="../../d8/de1/group__type__trait.html#d9/dfd/structstan_1_1math_1_1append__return__type_3_01_eigen_1_1_matrix_3_01_t1_00_01_r_00_01_c_01_4_0055a8b04836654f8c0781baa8c862db5f">More...</a><br /></td></tr>
<tr class="separator:d9/dfd/structstan_1_1math_1_1append__return__type_3_01_eigen_1_1_matrix_3_01_t1_00_01_r_00_01_c_01_4_0055a8b04836654f8c0781baa8c862db5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d4/dfe/structstan_1_1math_1_1append__return__type_3_01std_1_1vector_3_01_t1_01_4_00_01std_1_1vector_3_01_t2_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d4/dfe/structstan_1_1math_1_1append__return__type_3_01std_1_1vector_3_01_t1_01_4_00_01std_1_1vector_3_01_t2_01_4_01_4">stan::math::append_return_type&lt; std::vector&lt; T1 &gt;, std::vector&lt; T2 &gt; &gt;</a></td></tr>
<tr class="memdesc:d4/dfe/structstan_1_1math_1_1append__return__type_3_01std_1_1vector_3_01_t1_01_4_00_01std_1_1vector_3_01_t2_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template metaprogram is used to compute the return type for append_array.  <a href="../../d8/de1/group__type__trait.html#d4/dfe/structstan_1_1math_1_1append__return__type_3_01std_1_1vector_3_01_t1_01_4_00_01std_1_1vector_3_01_t2_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:d4/dfe/structstan_1_1math_1_1append__return__type_3_01std_1_1vector_3_01_t1_01_4_00_01std_1_1vector_3_01_t2_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/daa/structstan_1_1base__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d1/daa/structstan_1_1base__type">stan::base_type&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:d1/daa/structstan_1_1base__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogram structure to determine the base base type of a template argument.  <a href="../../d8/de1/group__type__trait.html#d1/daa/structstan_1_1base__type">More...</a><br /></td></tr>
<tr class="separator:d1/daa/structstan_1_1base__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d8d/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#dc/d8d/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4">stan::base_type&lt; T, std::enable_if_t&lt; is_std_vector&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:dc/d8d/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="../../d8/de1/group__type__trait.html#d1/daa/structstan_1_1base__type" title="Metaprogram structure to determine the base base type of a template argument. ">base_type</a> for vector to recursively return the inner base type.  <a href="../../d8/de1/group__type__trait.html#dc/d8d/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:dc/d8d/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/d9d/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#db/d9d/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4">stan::base_type&lt; T, std::enable_if_t&lt; is_eigen&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:db/d9d/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the base base type of values stored in an <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix.  <a href="../../d8/de1/group__type__trait.html#db/d9d/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:db/d9d/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/d09/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#db/d09/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4">stan::base_type&lt; T, std::enable_if_t&lt; is_complex&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:db/d09/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the base type for values stored in a complex number.  <a href="../../d8/de1/group__type__trait.html#db/d09/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:db/d09/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/d7a/structstan_1_1math_1_1child__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d6/d7a/structstan_1_1math_1_1child__type">stan::math::child_type&lt; T &gt;</a></td></tr>
<tr class="memdesc:d6/d7a/structstan_1_1math_1_1child__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template class for metaprogram to compute child type of T.  <a href="../../d8/de1/group__type__trait.html#d6/d7a/structstan_1_1math_1_1child__type">More...</a><br /></td></tr>
<tr class="separator:d6/d7a/structstan_1_1math_1_1child__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/dc1/structstan_1_1math_1_1child__type_3_01_t__struct_3_01_t__child_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#de/dc1/structstan_1_1math_1_1child__type_3_01_t__struct_3_01_t__child_01_4_01_4">stan::math::child_type&lt; T_struct&lt; T_child &gt; &gt;</a></td></tr>
<tr class="memdesc:de/dc1/structstan_1_1math_1_1child__type_3_01_t__struct_3_01_t__child_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for template classes / structs.  <a href="../../d8/de1/group__type__trait.html#de/dc1/structstan_1_1math_1_1child__type_3_01_t__struct_3_01_t__child_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:de/dc1/structstan_1_1math_1_1child__type_3_01_t__struct_3_01_t__child_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d56/structstan_1_1math_1_1conjunction.html">stan::math::conjunction&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::true_type when instantiated with zero or more template parameters, all of which extend the std::true_type.  <a href="../../da/d56/structstan_1_1math_1_1conjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d3d/structstan_1_1math_1_1disjunction.html">stan::math::disjunction&lt; Conds &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::false_type when instantiated with zero or more template parameters, all of which extend the std::false_type.  <a href="../../d8/d3d/structstan_1_1math_1_1disjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dda/structstan_1_1math_1_1include__summand.html">stan::math::include_summand&lt; propto, T, T_pack &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate whether a summand needs to be included in a proportional (log) probability calculation.  <a href="../../d1/dda/structstan_1_1math_1_1include__summand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dc3/structstan_1_1math_1_1include__summand_3_01propto_00_01_t_01_4.html">stan::math::include_summand&lt; propto, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if a term with the specified propto value and subterm types should be included in a proportionality calculation.  <a href="../../da/dc3/structstan_1_1math_1_1include__summand_3_01propto_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d9a/structstan_1_1math_1_1index__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#de/d9a/structstan_1_1math_1_1index__type">stan::math::index_type&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:de/d9a/structstan_1_1math_1_1index__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template class for the metaprogram to compute the index type of a container.  <a href="../../d8/de1/group__type__trait.html#de/d9a/structstan_1_1math_1_1index__type">More...</a><br /></td></tr>
<tr class="separator:de/d9a/structstan_1_1math_1_1index__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:df/d47/structstan_1_1math_1_1index__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#df/d47/structstan_1_1math_1_1index__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4">stan::math::index_type&lt; T, std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:df/d47/structstan_1_1math_1_1index__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="../../d8/de1/group__type__trait.html#de/d9a/structstan_1_1math_1_1index__type" title="Primary template class for the metaprogram to compute the index type of a container. ">index_type</a> for pointers.  <a href="../../d8/de1/group__type__trait.html#df/d47/structstan_1_1math_1_1index__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:df/d47/structstan_1_1math_1_1index__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d7/d10/structstan_1_1math_1_1index__type_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d7/d10/structstan_1_1math_1_1index__type_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4">stan::math::index_type&lt; T, require_std_vector_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:d7/d10/structstan_1_1math_1_1index__type_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram class to compute the type of index for a standard vector.  <a href="../../d8/de1/group__type__trait.html#d7/d10/structstan_1_1math_1_1index__type_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:d7/d10/structstan_1_1math_1_1index__type_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d10/structstan_1_1math_1_1index__type_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#de/d10/structstan_1_1math_1_1index__type_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4">stan::math::index_type&lt; T, require_eigen_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:de/d10/structstan_1_1math_1_1index__type_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining typedef for the type of index for an <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix, vector, or row vector.  <a href="../../d8/de1/group__type__trait.html#de/d10/structstan_1_1math_1_1index__type_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:de/d10/structstan_1_1math_1_1index__type_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d8e/structstan_1_1is__arena__matrix.html">stan::is_arena_matrix&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is <code>arena_matrix&lt;T&gt;</code>  <a href="../../d1/d8e/structstan_1_1is__arena__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dff/structstan_1_1is__autodiff.html">stan::is_autodiff&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if decayed type is a var or fvar.  <a href="../../d1/dff/structstan_1_1is__autodiff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d11/structstan_1_1is__base__pointer__convertible.html">stan::is_base_pointer_convertible&lt; Base, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type's pointer is convertible to a templated base type's pointer.  <a href="../../dd/d11/structstan_1_1is__base__pointer__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de1/structstan_1_1internal_1_1is__complex__impl.html">stan::internal::is_complex_impl&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a member constant <code>value</code> which is equal to <code>true</code> if <code>T</code> is an instance of <code>std::complex</code> and <code>false</code> otherwise.  <a href="../../d5/de1/structstan_1_1internal_1_1is__complex__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d57/structstan_1_1is__complex.html">stan::is_complex&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>T</code> is an arithmetic type (that is, an instance of <code>std::complex</code>) or a cv-qualified version thereof, provides the member constant <code>value</code> equal <code>true</code>; for any other type the value is <code>false</code>.  <a href="../../d0/d57/structstan_1_1is__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d0b/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#de/d0b/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4">stan::scalar_type&lt; T, std::enable_if_t&lt; is_complex&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:de/d0b/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the scalar type for values stored in a complex number.  <a href="../../d8/de1/group__type__trait.html#de/d0b/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:de/d0b/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d70/structstan_1_1is__constant.html">stan::is_constant&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogramming struct to detect whether a given type is constant in the mathematical sense (not the C++ <code>const</code> sense).  <a href="../../d5/d70/structstan_1_1is__constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0f/structstan_1_1is__constant_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4.html">stan::is_constant&lt; T, require_std_vector_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value and sets it to true if the type of the elements in the provided std::vector is constant, false otherwise.  <a href="../../da/d0f/structstan_1_1is__constant_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d39/structstan_1_1is__constant_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html">stan::is_constant&lt; T, require_eigen_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a public enum named value and sets it to true if the type of the elements in the provided <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> Matrix is constant, false otherwise.  <a href="../../d6/d39/structstan_1_1is__constant_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d41/structstan_1_1is__double__or__int.html">stan::is_double_or_int&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if decayed type is a double or integer.  <a href="../../dd/d41/structstan_1_1is__double__or__int.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7d/structstan_1_1is__eigen.html">stan::is_eigen&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type derives from <code>EigenBase</code>  <a href="../../dc/d7d/structstan_1_1is__eigen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d0/d6d/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d0/d6d/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4">stan::scalar_type&lt; T, std::enable_if_t&lt; is_eigen&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:d0/d6d/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the base scalar type of values stored in an <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix.  <a href="../../d8/de1/group__type__trait.html#d0/d6d/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:d0/d6d/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/d44/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d3/d44/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4">stan::value_type&lt; T, std::enable_if_t&lt; is_eigen&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:d3/d44/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the type of values stored in an <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix, vector, or row vector.  <a href="../../d8/de1/group__type__trait.html#d3/d44/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:d3/d44/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d22/structstan_1_1is__eigen__array.html">stan::is_eigen_array&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is derived from <code>Eigen::ArrayBase</code>  <a href="../../dc/d22/structstan_1_1is__eigen__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d7c/structstan_1_1is__eigen__contiguous__map.html">stan::is_eigen_contiguous_map&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is an <code>Eigen::Map</code> with contiguous stride.  <a href="../../d7/d7c/structstan_1_1is__eigen__contiguous__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dbf/structstan_1_1is__eigen__dense__base.html">stan::is_eigen_dense_base&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::DenseBase.  <a href="../../da/dbf/structstan_1_1is__eigen__dense__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d6f/structstan_1_1is__eigen__matrix__dynamic.html">stan::is_eigen_matrix_dynamic&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::MatrixBase and has columns and rows not equal to 1.  <a href="../../db/d6f/structstan_1_1is__eigen__matrix__dynamic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d4e/structstan_1_1is__eigen__matrix__base.html">stan::is_eigen_matrix_base&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::MatrixBase.  <a href="../../d2/d4e/structstan_1_1is__eigen__matrix__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d06/structstan_1_1is__eigen__sparse__base.html">stan::is_eigen_sparse_base&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::SparseMatrixBase.  <a href="../../d5/d06/structstan_1_1is__eigen__sparse__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df3/structstan_1_1is__fvar.html">stan::is_fvar&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member function type which is defined to be false as the primitive scalar types cannot be a <a class="el" href="../../d0/dfb/structstan_1_1math_1_1fvar.html" title="This template class represents scalars used in forward-mode automatic differentiation, which consist of values and directional derivatives of the specified template type. ">stan::math::fvar</a> type.  <a href="../../d4/df3/structstan_1_1is__fvar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/ddf/structstan_1_1is__matrix.html">stan::is_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is derived from <code>Eigen::EigenBase</code> or is a <code>var_value</code> whose <code><a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type" title="Primary template class for metaprogram to compute the type of values stored in a container. ">value_type</a></code> is derived from <code>Eigen::EigenBase</code>  <a href="../../de/ddf/structstan_1_1is__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da2/structstan_1_1is__rev__matrix.html">stan::is_rev_matrix&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>  <a href="../../d4/da2/structstan_1_1is__rev__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dd5/structstan_1_1is__rev__col__vector.html">stan::is_rev_col_vector&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>.  <a href="../../d6/dd5/structstan_1_1is__rev__col__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dd0/structstan_1_1is__rev__row__vector.html">stan::is_rev_row_vector&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>.  <a href="../../d7/dd0/structstan_1_1is__rev__row__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d4d/structstan_1_1is__rev__vector.html">stan::is_rev_vector&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>.  <a href="../../d2/d4d/structstan_1_1is__rev__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d8f/structstan_1_1is__stan__scalar.html">stan::is_stan_scalar&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if decayed type is a var, fvar, or arithmetic.  <a href="../../da/d8f/structstan_1_1is__stan__scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d9d/structstan_1_1is__var.html">stan::is_var&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be false as the primitive scalar types cannot be a <a class="el" href="../../d4/d84/namespacestan_1_1math.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> type.  <a href="../../df/d9d/structstan_1_1is__var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d6d/structstan_1_1is__var__dense__dynamic.html">stan::is_var_dense_dynamic&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type" title="Primary template class for metaprogram to compute the type of values stored in a container. ">value_type</a></code> is derived from <code>Eigen::EigenBase</code> and has dynamic rows and columns.  <a href="../../db/d6d/structstan_1_1is__var__dense__dynamic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dbb/structstan_1_1is__var__eigen.html">stan::is_var_eigen&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type" title="Primary template class for metaprogram to compute the type of values stored in a container. ">value_type</a></code> is derived from <code>Eigen::EigenBase</code>  <a href="../../dc/dbb/structstan_1_1is__var__eigen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d25/structstan_1_1is__var__matrix.html">stan::is_var_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type" title="Primary template class for metaprogram to compute the type of values stored in a container. ">value_type</a></code> is derived from <code>Eigen::EigenBase</code>  <a href="../../d6/d25/structstan_1_1is__var__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d2f/structstan_1_1is__var__col__vector.html">stan::is_var_col_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type" title="Primary template class for metaprogram to compute the type of values stored in a container. ">value_type</a></code> is derived from <code>Eigen::EigenBase</code>.  <a href="../../d9/d2f/structstan_1_1is__var__col__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d2c/structstan_1_1is__var__row__vector.html">stan::is_var_row_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type" title="Primary template class for metaprogram to compute the type of values stored in a container. ">value_type</a></code> is derived from <code>Eigen::EigenBase</code>.  <a href="../../dc/d2c/structstan_1_1is__var__row__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dbf/structstan_1_1is__var__vector.html">stan::is_var_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type" title="Primary template class for metaprogram to compute the type of values stored in a container. ">value_type</a></code> is derived from <code>Eigen::EigenBase</code>.  <a href="../../d9/dbf/structstan_1_1is__var__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d38/structstan_1_1is__any__var__matrix.html">stan::is_any_var_matrix&lt; Types &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any types in a parameter pack are a <code>var_value</code> whose <code><a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type" title="Primary template class for metaprogram to compute the type of values stored in a container. ">value_type</a></code> is derived from <code>Eigen::EigenBase</code>  <a href="../../d7/d38/structstan_1_1is__any__var__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d4f/structstan_1_1is__var__or__arithmetic__type.html">stan::is_var_or_arithmetic_type&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member value which is defined to be true (1) if the unqualified cv of type T or its underlying type (if a container) is either var or an arithmetic type, and false (0) otherwise.  <a href="../../dd/d4f/structstan_1_1is__var__or__arithmetic__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d64/structstan_1_1is__vari.html">stan::is_vari&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for checking if value of T minus cv qualifier and pointer is a vari.  <a href="../../d1/d64/structstan_1_1is__vari.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/db6/structstan_1_1is__std__vector.html">stan::is_std_vector&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base implementation for checking if type is std vector.  <a href="../../d0/db6/structstan_1_1is__std__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d1b/structstan_1_1internal_1_1is__eigen__col__vector__impl.html">stan::internal::is_eigen_col_vector_impl&lt; T, bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying implementation for detecting if an <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> Matrix is a column vector.  <a href="../../d0/d1b/structstan_1_1internal_1_1is__eigen__col__vector__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d04/structstan_1_1internal_1_1is__eigen__col__vector__impl_3_01_t_00_01false_01_4.html">stan::internal::is_eigen_col_vector_impl&lt; T, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for when type is not an eigen vector.  <a href="../../d3/d04/structstan_1_1internal_1_1is__eigen__col__vector__impl_3_01_t_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dbc/structstan_1_1internal_1_1is__eigen__row__vector__impl.html">stan::internal::is_eigen_row_vector_impl&lt; T, bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying implementation for detecting if an <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> Matrix is a row vector.  <a href="../../d1/dbc/structstan_1_1internal_1_1is__eigen__row__vector__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd7/structstan_1_1internal_1_1is__eigen__row__vector__impl_3_01_t_00_01false_01_4.html">stan::internal::is_eigen_row_vector_impl&lt; T, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for when type is not an eigen vector.  <a href="../../d3/dd7/structstan_1_1internal_1_1is__eigen__row__vector__impl_3_01_t_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d21/structstan_1_1internal_1_1is__col__vector__impl.html">stan::internal::is_col_vector_impl&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying implementation for detecting if a Matrix is a column vector.  <a href="../../dc/d21/structstan_1_1internal_1_1is__col__vector__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d5c/structstan_1_1internal_1_1is__col__vector__impl_3_01_t_00_01false_01_4.html">stan::internal::is_col_vector_impl&lt; T, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for when type is not a vector.  <a href="../../d8/d5c/structstan_1_1internal_1_1is__col__vector__impl_3_01_t_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d83/structstan_1_1internal_1_1is__row__vector__impl.html">stan::internal::is_row_vector_impl&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying implementation for detecting if a Matrix is a row vector.  <a href="../../d1/d83/structstan_1_1internal_1_1is__row__vector__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d54/structstan_1_1internal_1_1is__row__vector__impl_3_01_t_00_01false_01_4.html">stan::internal::is_row_vector_impl&lt; T, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for when type is not an vector.  <a href="../../d7/d54/structstan_1_1internal_1_1is__row__vector__impl_3_01_t_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d37/structstan_1_1is__eigen__col__vector.html">stan::is_eigen_col_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T is an eigen matrix with 1 row at compile time this has a static member with a value of true.  <a href="../../d6/d37/structstan_1_1is__eigen__col__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dff/structstan_1_1is__col__vector.html">stan::is_col_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T has a static comple time constant type <code>ColsAtCompileTime</code> equal to 1 this has a static member with a value of true.  <a href="../../d4/dff/structstan_1_1is__col__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dc1/structstan_1_1is__eigen__row__vector.html">stan::is_eigen_row_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T is an eigen matrix with 1 column at compile time this has a static member with a value of true.  <a href="../../dd/dc1/structstan_1_1is__eigen__row__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d90/structstan_1_1is__row__vector.html">stan::is_row_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T has a static comple time constant type <code>RowsAtCompileTime</code> equal to 1 this has a static member with a value of true.  <a href="../../d5/d90/structstan_1_1is__row__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d3b/structstan_1_1is__eigen__vector.html">stan::is_eigen_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T is an eigen matrix with 1 column or 1 row at compile time this has a static member with a value of true.  <a href="../../d7/d3b/structstan_1_1is__eigen__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d82/structstan_1_1is__vector.html">stan::is_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T is either an eigen matrix with 1 column or 1 row at compile time or a standard vector, this has a static member with a value of true.  <a href="../../d4/d82/structstan_1_1is__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d0c/structstan_1_1internal_1_1is__std__vector__impl.html">stan::internal::is_std_vector_impl&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This underlying implementation is used when the type is not an std vector.  <a href="../../d4/d0c/structstan_1_1internal_1_1is__std__vector__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df7/structstan_1_1internal_1_1is__std__vector__impl_3_01std_1_1vector_3_01_args_8_8_8_01_4_01_4.html">stan::internal::is_std_vector_impl&lt; std::vector&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This specialization implementation has a static member named value when the template type is an std vector.  <a href="../../d0/df7/structstan_1_1internal_1_1is__std__vector__impl_3_01std_1_1vector_3_01_args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d23/structstan_1_1is__std__vector_3_01_t_00_01std_1_1enable__if__t_3_01internal_1_1is__std__vector__28c6aea3001284899b87957f6f2ae7d6.html">stan::is_std_vector&lt; T, std::enable_if_t&lt; internal::is_std_vector_impl&lt; std::decay_t&lt; T &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the decayed type of T is a standard vector.  <a href="../../d2/d23/structstan_1_1is__std__vector_3_01_t_00_01std_1_1enable__if__t_3_01internal_1_1is__std__vector__28c6aea3001284899b87957f6f2ae7d6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/d73/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d6/d73/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4">stan::scalar_type&lt; T, std::enable_if_t&lt; is_std_vector&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:d6/d73/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="../../d8/de1/group__type__trait.html#d6/dd9/structstan_1_1scalar__type" title="Metaprogram structure to determine the base scalar type of a template argument. ">scalar_type</a> for vector to recursively return the inner scalar type.  <a href="../../d8/de1/group__type__trait.html#d6/d73/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:d6/d73/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/d30/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d1/d30/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4">stan::value_type&lt; T, std::enable_if_t&lt; is_std_vector&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:d1/d30/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram class to compute the type of values stored in a standard vector.  <a href="../../d8/de1/group__type__trait.html#d1/d30/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:d1/d30/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d45/structstan_1_1is__vector__like.html">stan::is_vector_like&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram indicates whether a type is vector_like.  <a href="../../d3/d45/structstan_1_1is__vector__like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/d04/structstan_1_1partials__return__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d3/d04/structstan_1_1partials__return__type">stan::partials_return_type&lt; T, T_pack &gt;</a></td></tr>
<tr class="memdesc:d3/d04/structstan_1_1partials__return__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate the partial derivative type resulting from promoting all the scalar types of the template parameters.  <a href="../../d8/de1/group__type__trait.html#d3/d04/structstan_1_1partials__return__type">More...</a><br /></td></tr>
<tr class="separator:d3/d04/structstan_1_1partials__return__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d0/db7/structstan_1_1partials__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d0/db7/structstan_1_1partials__type">stan::partials_type&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:d0/db7/structstan_1_1partials__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base implementation will contain a static member function named type equal to the type passed into it.  <a href="../../d8/de1/group__type__trait.html#d0/db7/structstan_1_1partials__type">More...</a><br /></td></tr>
<tr class="separator:d0/db7/structstan_1_1partials__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d0/dc1/structstan_1_1real__return"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d0/dc1/structstan_1_1real__return">stan::real_return&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:d0/dc1/structstan_1_1real__return"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a member type alias named <code>type</code>, the value of which is the least type under Stan's assignability relation that can be assigned a <code>double</code> and all of the base types of the specified arguments after removing qualifiers (<code>const</code> and <code>volatile</code>) and decaying (lvalue to rvalue by removing references) and array to pointer).  <a href="../../d8/de1/group__type__trait.html#d0/dc1/structstan_1_1real__return">More...</a><br /></td></tr>
<tr class="separator:d0/dc1/structstan_1_1real__return"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d5/d1d/structstan_1_1scalar__lub"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d5/d1d/structstan_1_1scalar__lub">stan::scalar_lub&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:d5/d1d/structstan_1_1scalar__lub"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a member type named <code>type</code> that is the least scalar type to which both template parameter scalar types are assignable in Stan.  <a href="../../d8/de1/group__type__trait.html#d5/d1d/structstan_1_1scalar__lub">More...</a><br /></td></tr>
<tr class="separator:d5/d1d/structstan_1_1scalar__lub"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d8/d68/structstan_1_1return__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d8/d68/structstan_1_1return__type">stan::return_type&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:d8/d68/structstan_1_1return__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate the base scalar return type resulting from promoting all the scalar types of the template parameters to the least type to which all the base types of the arguments are assignable.  <a href="../../d8/de1/group__type__trait.html#d8/d68/structstan_1_1return__type">More...</a><br /></td></tr>
<tr class="separator:d8/d68/structstan_1_1return__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/dd9/structstan_1_1scalar__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d6/dd9/structstan_1_1scalar__type">stan::scalar_type&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:d6/dd9/structstan_1_1scalar__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogram structure to determine the base scalar type of a template argument.  <a href="../../d8/de1/group__type__trait.html#d6/dd9/structstan_1_1scalar__type">More...</a><br /></td></tr>
<tr class="separator:d6/dd9/structstan_1_1scalar__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d5/d53/structstan_1_1scalar__type__pre"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d5/d53/structstan_1_1scalar__type__pre">stan::scalar_type_pre&lt; T &gt;</a></td></tr>
<tr class="memdesc:d5/d53/structstan_1_1scalar__type__pre"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogram structure to determine the type of first container of the base scalar type of a template argument.  <a href="../../d8/de1/group__type__trait.html#d5/d53/structstan_1_1scalar__type__pre">More...</a><br /></td></tr>
<tr class="separator:d5/d53/structstan_1_1scalar__type__pre"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db9/classstan_1_1_std_vector_builder.html">stan::StdVectorBuilder&lt; used, T1, T2, T3, T4, T5, T6, T7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../df/db9/classstan_1_1_std_vector_builder.html" title="StdVectorBuilder allocates type T1 values to be used as intermediate values. ">StdVectorBuilder</a> allocates type T1 values to be used as intermediate values.  <a href="../../df/db9/classstan_1_1_std_vector_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/d27/structstan_1_1value__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type">stan::value_type&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:dd/d27/structstan_1_1value__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template class for metaprogram to compute the type of values stored in a container.  <a href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type">More...</a><br /></td></tr>
<tr class="separator:dd/d27/structstan_1_1value__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:da/d24/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#da/d24/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4">stan::value_type&lt; T, std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:da/d24/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for pointers returns the underlying value the pointer is pointing to.  <a href="../../d8/de1/group__type__trait.html#da/d24/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:da/d24/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/classstan_1_1_vector_builder.html">stan::VectorBuilder&lt; used, T1, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d7e/classstan_1_1_vector_builder.html" title="VectorBuilder allocates type T1 values to be used as intermediate values. ">VectorBuilder</a> allocates type T1 values to be used as intermediate values.  <a href="../../da/d7e/classstan_1_1_vector_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d66/classstan_1_1_vector_builder_helper.html">stan::VectorBuilderHelper&lt; T1, used, is_vec &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d7e/classstan_1_1_vector_builder.html" title="VectorBuilder allocates type T1 values to be used as intermediate values. ">VectorBuilder</a> allocates type T1 values to be used as intermediate values.  <a href="../../d6/d66/classstan_1_1_vector_builder_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfa/classstan_1_1_vector_builder_helper_3_01_t1_00_01true_00_01true_01_4.html">stan::VectorBuilderHelper&lt; T1, true, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for using a vector.  <a href="../../d2/dfa/classstan_1_1_vector_builder_helper_3_01_t1_00_01true_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/d3f/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__var_3_01_t_01_4_1_1value_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d6/d3f/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__var_3_01_t_01_4_1_1value_01_4_01_4">stan::scalar_type&lt; T, std::enable_if_t&lt; is_var&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:d6/d3f/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__var_3_01_t_01_4_1_1value_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization defining the scalar type of values stored in var_value.  <a href="../../d8/de1/group__type__trait.html#d6/d3f/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__var_3_01_t_01_4_1_1value_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:d6/d3f/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__var_3_01_t_01_4_1_1value_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d25/classstan_1_1math_1_1internal_1_1ops__partials__edge_3_01double_00_01var_01_4.html">stan::math::internal::ops_partials_edge&lt; double, var &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de8/classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00_01var_01_4.html">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, var &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class builds partial derivatives with respect to a set of operands.  <a href="../../d2/de8/classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00_01var_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d0b/structstan_1_1is__arena__matrix_3_01_t_00_01require__t_3_01internal_1_1is__arena__matrix__impl_382c328ab88094a24a9cfff97c4ae9a76.html">stan::is_arena_matrix&lt; T, require_t&lt; internal::is_arena_matrix_impl&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is <code>arena_matrix&lt;T&gt;</code>  <a href="../../d5/d0b/structstan_1_1is__arena__matrix_3_01_t_00_01require__t_3_01internal_1_1is__arena__matrix__impl_382c328ab88094a24a9cfff97c4ae9a76.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df4/structstan_1_1is__rev__matrix_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_3_01_t1ddd3dfbec50668d893a6befdfb0b45a.html">stan::is_rev_matrix&lt; T, require_all_t&lt; is_var&lt; scalar_type_t&lt; T &gt; &gt;, math::disjunction&lt; math::conjunction&lt; is_var&lt; T &gt;, is_eigen&lt; value_type_t&lt; T &gt; &gt; &gt;, is_eigen&lt; T &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>  <a href="../../d8/df4/structstan_1_1is__rev__matrix_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_3_01_t1ddd3dfbec50668d893a6befdfb0b45a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dd8/structstan_1_1is__rev__col__vector_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_30dc403fb8542198c3091e4e6e1e54ba5.html">stan::is_rev_col_vector&lt; T, require_all_t&lt; is_var&lt; scalar_type_t&lt; T &gt; &gt;, math::disjunction&lt; is_eigen_col_vector&lt; T &gt;, is_eigen_col_vector&lt; value_type_t&lt; T &gt; &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>.  <a href="../../df/dd8/structstan_1_1is__rev__col__vector_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_30dc403fb8542198c3091e4e6e1e54ba5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/df9/structstan_1_1is__rev__row__vector_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_3f675c2ac2e6bea3e3104996f22b12a50.html">stan::is_rev_row_vector&lt; T, require_all_t&lt; is_var&lt; scalar_type_t&lt; T &gt; &gt;, math::disjunction&lt; is_eigen_row_vector&lt; T &gt;, is_eigen_row_vector&lt; value_type_t&lt; T &gt; &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>.  <a href="../../d5/df9/structstan_1_1is__rev__row__vector_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_3f675c2ac2e6bea3e3104996f22b12a50.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d51/structstan_1_1is__rev__vector_3_01_t_00_01require__any__t_3_01is__rev__col__vector_3_01_t_01_4_0ee983b7fdcdd0eeacbfc45ed12837bd6.html">stan::is_rev_vector&lt; T, require_any_t&lt; is_rev_col_vector&lt; T &gt;, is_rev_row_vector&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>.  <a href="../../d7/d51/structstan_1_1is__rev__vector_3_01_t_00_01require__any__t_3_01is__rev__col__vector_3_01_t_01_4_0ee983b7fdcdd0eeacbfc45ed12837bd6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d9d/structstan_1_1is__var_3_01_t_00_01std_1_1enable__if__t_3_01internal_1_1is__var__impl_3_01std_1_14fc46eebc2d7d167cda3892bd7b10182.html">stan::is_var&lt; T, std::enable_if_t&lt; internal::is_var_impl&lt; std::decay_t&lt; T &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for checking if value of T minus cv qualifier is a var_value.  <a href="../../d3/d9d/structstan_1_1is__var_3_01_t_00_01std_1_1enable__if__t_3_01internal_1_1is__var__impl_3_01std_1_14fc46eebc2d7d167cda3892bd7b10182.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/da1/structstan_1_1is__vari_3_01_t_00_01require__t_3_01internal_1_1is__vari__impl_3_01std_1_1decay__t_3_01_t_01_4_01_4_01_4_01_4.html">stan::is_vari&lt; T, require_t&lt; internal::is_vari_impl&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for checking if value of T minus cv qualifier and pointer is a vari_value.  <a href="../../d3/da1/structstan_1_1is__vari_3_01_t_00_01require__t_3_01internal_1_1is__vari__impl_3_01std_1_1decay__t_3_01_t_01_4_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d4/da0/structstan_1_1partials__type_3_01_t_00_01require__var__t_3_01_t_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#d4/da0/structstan_1_1partials__type_3_01_t_00_01require__var__t_3_01_t_01_4_01_4">stan::partials_type&lt; T, require_var_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:d4/da0/structstan_1_1partials__type_3_01_t_00_01require__var__t_3_01_t_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of partials type returns double if input type is a double.  <a href="../../d8/de1/group__type__trait.html#d4/da0/structstan_1_1partials__type_3_01_t_00_01require__var__t_3_01_t_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:d4/da0/structstan_1_1partials__type_3_01_t_00_01require__var__t_3_01_t_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad1046e42476333dc3c08c35bfe420302"><td class="memTemplParams" colspan="2">template&lt;bool B&gt; </td></tr>
<tr class="memitem:gad1046e42476333dc3c08c35bfe420302"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gad1046e42476333dc3c08c35bfe420302">stan::bool_constant</a> = std::integral_constant&lt; bool, B &gt;</td></tr>
<tr class="memdesc:gad1046e42476333dc3c08c35bfe420302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for structs used for wraps a static constant of bool.  <a href="../../d8/de1/group__type__trait.html#gad1046e42476333dc3c08c35bfe420302">More...</a><br /></td></tr>
<tr class="separator:gad1046e42476333dc3c08c35bfe420302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76542442910faefbee636785a9f34091"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga76542442910faefbee636785a9f34091"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga76542442910faefbee636785a9f34091">stan::contains_fvar</a> = math::disjunction&lt; is_fvar&lt; scalar_type_t&lt; T &gt;&gt;... &gt;</td></tr>
<tr class="memdesc:ga76542442910faefbee636785a9f34091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::true_type when instantiated with at least 1 template parameter that is a fvar.  <a href="../../d8/de1/group__type__trait.html#ga76542442910faefbee636785a9f34091">More...</a><br /></td></tr>
<tr class="separator:ga76542442910faefbee636785a9f34091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gaaa1b1eb615a4b1b30b46ef33ace88cdf">stan::contains_std_vector</a> = math::disjunction&lt; is_std_vector&lt; Ts &gt;... &gt;</td></tr>
<tr class="memdesc:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any types are std vectors.  <a href="../../d8/de1/group__type__trait.html#gaaa1b1eb615a4b1b30b46ef33ace88cdf">More...</a><br /></td></tr>
<tr class="separator:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga880b82cbb2b83ccaba2426e73996b8bd">stan::is_constant_all</a> = math::conjunction&lt; is_constant&lt; T &gt;... &gt;</td></tr>
<tr class="memdesc:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogram defining an enum <code>value</code> which is <code>true</code> if all of the type parameters are constant (i.e., primitive types) and <code>false</code> otherwise.  <a href="../../d8/de1/group__type__trait.html#ga880b82cbb2b83ccaba2426e73996b8bd">More...</a><br /></td></tr>
<tr class="separator:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7feafa1620b2760383a7857b2fc2e2c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7feafa1620b2760383a7857b2fc2e2c0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga7feafa1620b2760383a7857b2fc2e2c0">stan::is_dense_dynamic</a> = internal::is_dense_dynamic_impl&lt; std::decay_t&lt; T &gt;&gt;</td></tr>
<tr class="memdesc:ga7feafa1620b2760383a7857b2fc2e2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::DenseBase and has dynamic rows and columns or is a <code>var_value&lt;&gt;</code> whose inner type satisfies the conditions above.  <a href="../../d8/de1/group__type__trait.html#ga7feafa1620b2760383a7857b2fc2e2c0">More...</a><br /></td></tr>
<tr class="separator:ga7feafa1620b2760383a7857b2fc2e2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga785a5342448197bf621913e8295b2748"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga785a5342448197bf621913e8295b2748"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga785a5342448197bf621913e8295b2748">stan::is_eigen_matrix_or_array</a> = math::disjunction&lt; is_eigen_matrix_base&lt; T &gt;, is_eigen_array&lt; T &gt;&gt;</td></tr>
<tr class="memdesc:ga785a5342448197bf621913e8295b2748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is derived from <code>Eigen::MatrixBase</code> or <code>Eigen::ArrayBase</code>  <a href="../../d8/de1/group__type__trait.html#ga785a5342448197bf621913e8295b2748">More...</a><br /></td></tr>
<tr class="separator:ga785a5342448197bf621913e8295b2748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ba4b41c5d4073b73b794ba0f51b416d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5ba4b41c5d4073b73b794ba0f51b416d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga5ba4b41c5d4073b73b794ba0f51b416d">stan::is_eigen_dense_dynamic</a> = <a class="el" href="../../d3/d5e/structstan_1_1internal_1_1is__eigen__matrix__dynamic__impl.html">stan::internal::is_eigen_matrix_dynamic_impl</a>&lt; std::decay_t&lt; T &gt;, <a class="el" href="../../da/dbf/structstan_1_1is__eigen__dense__base.html">stan::is_eigen_dense_base</a>&lt; std::decay_t&lt; T &gt;&gt;::value &gt;</td></tr>
<tr class="memdesc:ga5ba4b41c5d4073b73b794ba0f51b416d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::DenseBase and has dynamic rows and columns.  <a href="../../d8/de1/group__type__trait.html#ga5ba4b41c5d4073b73b794ba0f51b416d">More...</a><br /></td></tr>
<tr class="separator:ga5ba4b41c5d4073b73b794ba0f51b416d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cedb8a7f6d2c46ed31fc8e49710d74b"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:ga3cedb8a7f6d2c46ed31fc8e49710d74b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga3cedb8a7f6d2c46ed31fc8e49710d74b">stan::is_plain_type</a> = std::is_same&lt; std::decay_t&lt; S &gt;, plain_type_t&lt; S &gt;&gt;</td></tr>
<tr class="memdesc:ga3cedb8a7f6d2c46ed31fc8e49710d74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the template type <code>T</code> is an assignable type.  <a href="../../d8/de1/group__type__trait.html#ga3cedb8a7f6d2c46ed31fc8e49710d74b">More...</a><br /></td></tr>
<tr class="separator:ga3cedb8a7f6d2c46ed31fc8e49710d74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f2252ae22390725feb09d9ea11b7896"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0f2252ae22390725feb09d9ea11b7896"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga0f2252ae22390725feb09d9ea11b7896">stan::is_string_convertible</a> = std::is_convertible&lt; T, std::string &gt;</td></tr>
<tr class="memdesc:ga0f2252ae22390725feb09d9ea11b7896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces whether type is convertible to string.  <a href="../../d8/de1/group__type__trait.html#ga0f2252ae22390725feb09d9ea11b7896">More...</a><br /></td></tr>
<tr class="separator:ga0f2252ae22390725feb09d9ea11b7896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga9d36a4d6158f96c2321b4fbf55243ca8">stan::is_var_or_arithmetic</a> = math::conjunction&lt; is_var_or_arithmetic_type&lt; T &gt;... &gt;</td></tr>
<tr class="memdesc:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::true_type if all the provided types are either var or an arithmetic type, extends std::false_type otherwise.  <a href="../../d8/de1/group__type__trait.html#ga9d36a4d6158f96c2321b4fbf55243ca8">More...</a><br /></td></tr>
<tr class="separator:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1310fb459dbad72fa5594b6d1eaad959"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1310fb459dbad72fa5594b6d1eaad959"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga1310fb459dbad72fa5594b6d1eaad959">stan::partials_type_t</a> = typename partials_type&lt; T &gt;::type</td></tr>
<tr class="memdesc:ga1310fb459dbad72fa5594b6d1eaad959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for accessing the partial type.  <a href="../../d8/de1/group__type__trait.html#ga1310fb459dbad72fa5594b6d1eaad959">More...</a><br /></td></tr>
<tr class="separator:ga1310fb459dbad72fa5594b6d1eaad959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga546483131616701876a9f1307f5a413d"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga546483131616701876a9f1307f5a413d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga546483131616701876a9f1307f5a413d">stan::promote_args_t</a> = typename boost::math::tools::promote_args&lt; Args... &gt;::type</td></tr>
<tr class="memdesc:ga546483131616701876a9f1307f5a413d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for boost tools promote_args.  <a href="../../d8/de1/group__type__trait.html#ga546483131616701876a9f1307f5a413d">More...</a><br /></td></tr>
<tr class="separator:ga546483131616701876a9f1307f5a413d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d3fe14d5102916bf0b5b05712c833e"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gac9d3fe14d5102916bf0b5b05712c833e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">stan::real_return_t</a> = typename real_return&lt; Ts... &gt;::type</td></tr>
<tr class="memdesc:gac9d3fe14d5102916bf0b5b05712c833e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the real return type.  <a href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">More...</a><br /></td></tr>
<tr class="separator:gac9d3fe14d5102916bf0b5b05712c833e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c52a0fffdfffc70123211cead9c7dbf"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga6c52a0fffdfffc70123211cead9c7dbf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga6c52a0fffdfffc70123211cead9c7dbf">stan::complex_return_t</a> = std::complex&lt; real_return_t&lt; Ts... &gt;&gt;</td></tr>
<tr class="memdesc:ga6c52a0fffdfffc70123211cead9c7dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>std::complex</code> around the return type of the specified template parameters.  <a href="../../d8/de1/group__type__trait.html#ga6c52a0fffdfffc70123211cead9c7dbf">More...</a><br /></td></tr>
<tr class="separator:ga6c52a0fffdfffc70123211cead9c7dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad4ed0103c48143e708de631fbb83a7f"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gaad4ed0103c48143e708de631fbb83a7f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gaad4ed0103c48143e708de631fbb83a7f">stan::std_vector_return_t</a> = std::vector&lt; real_return_t&lt; Ts... &gt;&gt;</td></tr>
<tr class="memdesc:gaad4ed0103c48143e708de631fbb83a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>std::vector</code> around the return type of the specified template parameters.  <a href="../../d8/de1/group__type__trait.html#gaad4ed0103c48143e708de631fbb83a7f">More...</a><br /></td></tr>
<tr class="separator:gaad4ed0103c48143e708de631fbb83a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gab3412a1caaad7f8eef55a9ee2a0d3921">stan::matrix_return_t</a> = Eigen::Matrix&lt; real_return_t&lt; Ts... &gt;,-1,-1 &gt;</td></tr>
<tr class="memdesc:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , -1, -1&gt;</code> around the return type of the specified template parameters.  <a href="../../d8/de1/group__type__trait.html#gab3412a1caaad7f8eef55a9ee2a0d3921">More...</a><br /></td></tr>
<tr class="separator:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b070b6ae219eccccf07b44243307b8b"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga1b070b6ae219eccccf07b44243307b8b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga1b070b6ae219eccccf07b44243307b8b">stan::vector_return_t</a> = Eigen::Matrix&lt; real_return_t&lt; Ts... &gt;,-1, 1 &gt;</td></tr>
<tr class="memdesc:ga1b070b6ae219eccccf07b44243307b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , -1, 1&gt;</code> around the return type of the specified template parameters.  <a href="../../d8/de1/group__type__trait.html#ga1b070b6ae219eccccf07b44243307b8b">More...</a><br /></td></tr>
<tr class="separator:ga1b070b6ae219eccccf07b44243307b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga2fa4e21b37c08e6abce2919ac4c2cd57">stan::row_vector_return_t</a> = Eigen::Matrix&lt; real_return_t&lt; Ts... &gt;, 1,-1 &gt;</td></tr>
<tr class="memdesc:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , 1, -1&gt;</code> around the return type of the specified template parameters.  <a href="../../d8/de1/group__type__trait.html#ga2fa4e21b37c08e6abce2919ac4c2cd57">More...</a><br /></td></tr>
<tr class="separator:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gace9d2d5da99a3e14fcadd7bf0f6cffee">stan::scalar_lub_t</a> = typename scalar_lub&lt; T1, T2 &gt;::type</td></tr>
<tr class="memdesc:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type for the least upper bound of the specified template parameters in Stan's assignment ordering.  <a href="../../d8/de1/group__type__trait.html#gace9d2d5da99a3e14fcadd7bf0f6cffee">More...</a><br /></td></tr>
<tr class="separator:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbaff683cd2683209e6855e2c7aaeffe"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gacbaff683cd2683209e6855e2c7aaeffe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a> = typename return_type&lt; Ts... &gt;::type</td></tr>
<tr class="memdesc:gacbaff683cd2683209e6855e2c7aaeffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type for the return type of the specified template parameters.  <a href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">More...</a><br /></td></tr>
<tr class="separator:gacbaff683cd2683209e6855e2c7aaeffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57121ded0440567e8dfb0d80b1290922"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga57121ded0440567e8dfb0d80b1290922"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">stan::value_type_t</a> = typename value_type&lt; T &gt;::type</td></tr>
<tr class="memdesc:ga57121ded0440567e8dfb0d80b1290922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for accessing underlying type.  <a href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">More...</a><br /></td></tr>
<tr class="separator:ga57121ded0440567e8dfb0d80b1290922"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae29786dab3b9274d3f1d08f6904854eb"><td class="memItemLeft" align="right" valign="top">T_return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gae29786dab3b9274d3f1d08f6904854eb">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, fvar&lt; Dx &gt; &gt;::build</a> (Dx value)</td></tr>
<tr class="memdesc:gae29786dab3b9274d3f1d08f6904854eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the node to be stored on the autodiff graph.  <a href="#gae29786dab3b9274d3f1d08f6904854eb">More...</a><br /></td></tr>
<tr class="separator:gae29786dab3b9274d3f1d08f6904854eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_stan_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gad2a93cdd718b76d4994d0f7c6c05fbba">stan::get</a> (const T &amp;x, size_t n)</td></tr>
<tr class="memdesc:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the provided element.  <a href="../../d8/de1/group__type__trait.html#gad2a93cdd718b76d4994d0f7c6c05fbba">More...</a><br /></td></tr>
<tr class="separator:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga431bd201f09a215cccb16cda10a1e840"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga431bd201f09a215cccb16cda10a1e840"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga431bd201f09a215cccb16cda10a1e840">stan::get</a> (const std::vector&lt; T &gt; &amp;x, size_t n)</td></tr>
<tr class="memdesc:ga431bd201f09a215cccb16cda10a1e840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the n-th element of the provided std::vector.  <a href="../../d8/de1/group__type__trait.html#ga431bd201f09a215cccb16cda10a1e840">More...</a><br /></td></tr>
<tr class="separator:ga431bd201f09a215cccb16cda10a1e840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98afb6ae5281b82b30caa793e205f6ae"><td class="memTemplParams" colspan="2">template&lt;typename T , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga98afb6ae5281b82b30caa793e205f6ae"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga98afb6ae5281b82b30caa793e205f6ae">stan::math::size</a> (const T &amp;m)</td></tr>
<tr class="memdesc:ga98afb6ae5281b82b30caa793e205f6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size (number of the elements) of a <code><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a></code> or <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt;<a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>&lt;T&gt;&gt;</code>.  <a href="../../d8/de1/group__type__trait.html#ga98afb6ae5281b82b30caa793e205f6ae">More...</a><br /></td></tr>
<tr class="separator:ga98afb6ae5281b82b30caa793e205f6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9a1e2f6c725ab45a9a0d5335ae9b0c1"><td class="memTemplParams" colspan="2">template&lt;typename ScalarT , require_stan_scalar_t&lt; ScalarT &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab9a1e2f6c725ab45a9a0d5335ae9b0c1"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gab9a1e2f6c725ab45a9a0d5335ae9b0c1">stan::math::size_mvt</a> (const ScalarT &amp;)</td></tr>
<tr class="memdesc:gab9a1e2f6c725ab45a9a0d5335ae9b0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the size of a multivariate argument.  <a href="../../d8/de1/group__type__trait.html#gab9a1e2f6c725ab45a9a0d5335ae9b0c1">More...</a><br /></td></tr>
<tr class="separator:gab9a1e2f6c725ab45a9a0d5335ae9b0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b28065e82cdcee1c320a7120cb8a83d"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:ga9b28065e82cdcee1c320a7120cb8a83d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga9b28065e82cdcee1c320a7120cb8a83d">stan::math::internal::broadcast_array&lt; T &gt;::operator=</a> (const Y &amp;m)</td></tr>
<tr class="memdesc:ga9b28065e82cdcee1c320a7120cb8a83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast array can be assigned a scalar or a vector.  <a href="#ga9b28065e82cdcee1c320a7120cb8a83d">More...</a><br /></td></tr>
<tr class="separator:ga9b28065e82cdcee1c320a7120cb8a83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bc34a86c0bb1a9853b36aa4c952a4dc"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga0bc34a86c0bb1a9853b36aa4c952a4dc">stan::math::internal::empty_broadcast_array&lt; T, S, Enable &gt;::operator[]</a> (int)</td></tr>
<tr class="memdesc:ga0bc34a86c0bb1a9853b36aa4c952a4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <a href="#ga0bc34a86c0bb1a9853b36aa4c952a4dc">More...</a><br /></td></tr>
<tr class="separator:ga0bc34a86c0bb1a9853b36aa4c952a4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga390dff20f30679c8e57ca2c3efe6d766"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:ga390dff20f30679c8e57ca2c3efe6d766"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga390dff20f30679c8e57ca2c3efe6d766">stan::math::internal::empty_broadcast_array&lt; T, S, Enable &gt;::operator=</a> (const Y &amp;)</td></tr>
<tr class="memdesc:ga390dff20f30679c8e57ca2c3efe6d766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <a href="#ga390dff20f30679c8e57ca2c3efe6d766">More...</a><br /></td></tr>
<tr class="separator:ga390dff20f30679c8e57ca2c3efe6d766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf06037332423259c9f5fa57c9b72ad3b"><td class="memItemLeft" align="right" valign="top">ViewElt &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gaf06037332423259c9f5fa57c9b72ad3b">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator[]</a> (int)</td></tr>
<tr class="memdesc:gaf06037332423259c9f5fa57c9b72ad3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <a href="#gaf06037332423259c9f5fa57c9b72ad3b">More...</a><br /></td></tr>
<tr class="separator:gaf06037332423259c9f5fa57c9b72ad3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a702889907a3c12704df6c514fcc07"><td class="memItemLeft" align="right" valign="top">ViewElt &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga80a702889907a3c12704df6c514fcc07">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator()</a> (int)</td></tr>
<tr class="memdesc:ga80a702889907a3c12704df6c514fcc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <a href="#ga80a702889907a3c12704df6c514fcc07">More...</a><br /></td></tr>
<tr class="separator:ga80a702889907a3c12704df6c514fcc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga501ec44e68851a8396f5f693e35a2e69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga501ec44e68851a8396f5f693e35a2e69">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator=</a> (const T_arg &amp;)</td></tr>
<tr class="memdesc:ga501ec44e68851a8396f5f693e35a2e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <a href="#ga501ec44e68851a8396f5f693e35a2e69">More...</a><br /></td></tr>
<tr class="separator:ga501ec44e68851a8396f5f693e35a2e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84d157dabee552a681aa5e4406b86474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga84d157dabee552a681aa5e4406b86474">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator+=</a> (T_arg)</td></tr>
<tr class="memdesc:ga84d157dabee552a681aa5e4406b86474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <a href="#ga84d157dabee552a681aa5e4406b86474">More...</a><br /></td></tr>
<tr class="separator:ga84d157dabee552a681aa5e4406b86474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50070330d69c12c87811fcaf4e643803"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga50070330d69c12c87811fcaf4e643803">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator-=</a> (T_arg)</td></tr>
<tr class="memdesc:ga50070330d69c12c87811fcaf4e643803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <a href="#ga50070330d69c12c87811fcaf4e643803">More...</a><br /></td></tr>
<tr class="separator:ga50070330d69c12c87811fcaf4e643803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd58c5861f0ee94465a97f78b2a00f0"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga8fd58c5861f0ee94465a97f78b2a00f0">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::row</a> (int)</td></tr>
<tr class="memdesc:ga8fd58c5861f0ee94465a97f78b2a00f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <a href="#ga8fd58c5861f0ee94465a97f78b2a00f0">More...</a><br /></td></tr>
<tr class="separator:ga8fd58c5861f0ee94465a97f78b2a00f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga354e6529ea257ab6475be87e7c217ce9"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga354e6529ea257ab6475be87e7c217ce9">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::col</a> (int)</td></tr>
<tr class="memdesc:ga354e6529ea257ab6475be87e7c217ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <a href="#ga354e6529ea257ab6475be87e7c217ce9">More...</a><br /></td></tr>
<tr class="separator:ga354e6529ea257ab6475be87e7c217ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a1f786a0f0544b5b9b10800518fa161"><td class="memItemLeft" align="right" valign="top">T_return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga1a1f786a0f0544b5b9b10800518fa161">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, T_return_type &gt;::build</a> (double value)</td></tr>
<tr class="memdesc:ga1a1f786a0f0544b5b9b10800518fa161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the node to be stored on the autodiff graph.  <a href="#ga1a1f786a0f0544b5b9b10800518fa161">More...</a><br /></td></tr>
<tr class="separator:ga1a1f786a0f0544b5b9b10800518fa161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0af4c158839e8c4c401e0f7e78bb4dc6"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;std::is_same&lt;std::decay_t&lt;T_actual&gt;,                                          std::decay_t&lt;T_desired&gt;&gt;::value                             &amp;&amp; !is_eigen&lt;T_desired&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga0af4c158839e8c4c401e0f7e78bb4dc6"><td class="memTemplItemLeft" align="right" valign="top">T_actual &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga0af4c158839e8c4c401e0f7e78bb4dc6">stan::math::forward_as</a> (T_actual &amp;&amp;a)</td></tr>
<tr class="memdesc:ga0af4c158839e8c4c401e0f7e78bb4dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume which type we get.  <a href="../../d8/de1/group__type__trait.html#ga0af4c158839e8c4c401e0f7e78bb4dc6">More...</a><br /></td></tr>
<tr class="separator:ga0af4c158839e8c4c401e0f7e78bb4dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;              !std::is_same&lt;std::decay&lt;T_actual&gt;, std::decay&lt;T_desired&gt;&gt;::value              &amp;&amp; (!is_eigen&lt;T_desired&gt;::value || !is_eigen&lt;T_actual&gt;::value)&gt;&gt; </td></tr>
<tr class="memitem:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="memTemplItemLeft" align="right" valign="top">T_desired&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga6cc77bba018fff06dd1f0f0f2d79e5b9">stan::math::forward_as</a> (const T_actual &amp;a)</td></tr>
<tr class="memdesc:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume which type we get.  <a href="../../d8/de1/group__type__trait.html#ga6cc77bba018fff06dd1f0f0f2d79e5b9">More...</a><br /></td></tr>
<tr class="separator:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga385d807274aa40985a59c273d49cf9cd"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , require_eigen_t&lt; T_desired &gt; *  = nullptr, std::enable_if_t&lt; std::is_same&lt; value_type_t&lt; T_actual &gt;, value_type_t&lt; T_desired &gt;&gt;::value &amp;&amp;is_eigen&lt; T_desired &gt;::value &amp;&amp;is_eigen&lt; T_actual &gt;::value &amp;&amp;internal::eigen_static_size_match(T_desired::RowsAtCompileTime, std::decay_t&lt; T_actual &gt;::RowsAtCompileTime)&amp;&amp;internal::eigen_static_size_match(T_desired::ColsAtCompileTime, std::decay_t&lt; T_actual &gt;::ColsAtCompileTime)&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga385d807274aa40985a59c273d49cf9cd"><td class="memTemplItemLeft" align="right" valign="top">T_actual &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga385d807274aa40985a59c273d49cf9cd">stan::math::forward_as</a> (T_actual &amp;&amp;a)</td></tr>
<tr class="memdesc:ga385d807274aa40985a59c273d49cf9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume which type we get.  <a href="../../d8/de1/group__type__trait.html#ga385d807274aa40985a59c273d49cf9cd">More...</a><br /></td></tr>
<tr class="separator:ga385d807274aa40985a59c273d49cf9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd89dca2a48f398e759d882af2e62ddd"><td class="memItemLeft" align="right" valign="top">var&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gacd89dca2a48f398e759d882af2e62ddd">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, var &gt;::build</a> (double value)</td></tr>
<tr class="memdesc:gacd89dca2a48f398e759d882af2e62ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the node to be stored on the autodiff graph.  <a href="#gacd89dca2a48f398e759d882af2e62ddd">More...</a><br /></td></tr>
<tr class="separator:gacd89dca2a48f398e759d882af2e62ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="d4/d76/structstan_1_1math_1_1append__return__type" id="d4/d76/structstan_1_1math_1_1append__return__type"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::math::append_return_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a7144fe859b1afd7a0cbc9367d79f5bfb"></a>typedef <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d4/dff/structstan_1_1math_1_1append__return__type_3_01int_00_01int_01_4" id="d4/dff/structstan_1_1math_1_1append__return__type_3_01int_00_01int_01_4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::math::append_return_type&lt; int, int &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a468680aa7eb05d32aab71b717b4586e3"></a>typedef int</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d9/dfd/structstan_1_1math_1_1append__return__type_3_01_eigen_1_1_matrix_3_01_t1_00_01_r_00_01_c_01_4_0055a8b04836654f8c0781baa8c862db5f" id="d9/dfd/structstan_1_1math_1_1append__return__type_3_01_eigen_1_1_matrix_3_01_t1_00_01_r_00_01_c_01_4_0055a8b04836654f8c0781baa8c862db5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::math::append_return_type&lt; Eigen::Matrix&lt; T1, R, C &gt;, Eigen::Matrix&lt; T2, R, C &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac797c873a640e6d5d9bde0ef966ff130"></a>typedef typename Matrix<br class="typebreak" />
&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;, R, <br class="typebreak" />
C &gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d4/dfe/structstan_1_1math_1_1append__return__type_3_01std_1_1vector_3_01_t1_01_4_00_01std_1_1vector_3_01_t2_01_4_01_4" id="d4/dfe/structstan_1_1math_1_1append__return__type_3_01std_1_1vector_3_01_t1_01_4_00_01std_1_1vector_3_01_t2_01_4_01_4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::math::append_return_type&lt; std::vector&lt; T1 &gt;, std::vector&lt; T2 &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aaa1edadccb08ee8ddce14b5873b426bd"></a>typedef typename vector<br class="typebreak" />
&lt; typename <a class="el" href="../../d8/de1/group__type__trait.html#d4/d76/structstan_1_1math_1_1append__return__type">append_return_type</a><br class="typebreak" />
&lt; T1, T2 &gt;::<a class="el" href="../../d8/de1/group__type__trait.html#aaa1edadccb08ee8ddce14b5873b426bd">type</a> &gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d1/daa/structstan_1_1base__type" id="d1/daa/structstan_1_1base__type"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::base_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab27c645fd17c84c18c680636f36580a5"></a>typedef decay_t&lt; T &gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="dc/d8d/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4" id="dc/d8d/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::base_type&lt; T, std::enable_if_t&lt; is_std_vector&lt; T &gt;::value &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a13fb29bfc81687310587726035a09dea"></a>typedef <a class="el" href="../../da/dce/namespacestan.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; typename <br class="typebreak" />
decay_t&lt; T &gt;::<a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type">value_type</a> &gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="db/d9d/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4" id="db/d9d/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::base_type&lt; T, std::enable_if_t&lt; is_eigen&lt; T &gt;::value &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="afc9cccbd249546d190af586e77ad421c"></a>typedef <a class="el" href="../../da/dce/namespacestan.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; typename <br class="typebreak" />
decay_t&lt; T &gt;::Scalar &gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="db/d09/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4" id="db/d09/structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::base_type&lt; T, std::enable_if_t&lt; is_complex&lt; T &gt;::value &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a71adbaf424e9812346c7ced0a0f870bf"></a>typedef <a class="el" href="../../da/dce/namespacestan.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; typename <br class="typebreak" />
decay_t&lt; T &gt;::<a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type">value_type</a> &gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d6/d7a/structstan_1_1math_1_1child__type" id="d6/d7a/structstan_1_1math_1_1child__type"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::math::child_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a1564baa173ca8846d1d474fc02cf497b"></a>typedef double</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="de/dc1/structstan_1_1math_1_1child__type_3_01_t__struct_3_01_t__child_01_4_01_4" id="de/dc1/structstan_1_1math_1_1child__type_3_01_t__struct_3_01_t__child_01_4_01_4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::math::child_type&lt; T_struct&lt; T_child &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ad0bb547dfe5532f95acd3af9e884143a"></a>typedef T_child</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="de/d9a/structstan_1_1math_1_1index__type" id="de/d9a/structstan_1_1math_1_1index__type"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::math::index_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="df/d47/structstan_1_1math_1_1index__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4" id="df/d47/structstan_1_1math_1_1index__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::math::index_type&lt; T, std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a2cae181344d330293e6cfb117825b667"></a>typedef int</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d7/d10/structstan_1_1math_1_1index__type_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4" id="d7/d10/structstan_1_1math_1_1index__type_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::math::index_type&lt; T, require_std_vector_t&lt; T &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a288da7aefbcb4d073d24eca768bbb857"></a>typedef typename decay_t&lt; T &gt;<br class="typebreak" />
::<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a98ff1baf06b8c5e2fc241bba99d0a97d">size_type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="de/d10/structstan_1_1math_1_1index__type_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4" id="de/d10/structstan_1_1math_1_1index__type_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::math::index_type&lt; T, require_eigen_t&lt; T &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac8514110d4cf003589df29b2342a3127"></a>typedef typename decay_t&lt; T &gt;<br class="typebreak" />
::Index</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="de/d0b/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4" id="de/d0b/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::scalar_type&lt; T, std::enable_if_t&lt; is_complex&lt; T &gt;::value &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a66b9642d8d3a183a736677b6b2eb1fd7"></a>typedef complex&lt; typename <br class="typebreak" />
decay_t&lt; T &gt;::<a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type">value_type</a> &gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d0/d6d/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4" id="d0/d6d/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::scalar_type&lt; T, std::enable_if_t&lt; is_eigen&lt; T &gt;::value &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a7dc869ecbcbf1316f16e48048d3e7223"></a>typedef <a class="el" href="../../da/dce/namespacestan.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a><br class="typebreak" />
&lt; typename decay_t&lt; T &gt;<br class="typebreak" />
::Scalar &gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d3/d44/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4" id="d3/d44/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::value_type&lt; T, std::enable_if_t&lt; is_eigen&lt; T &gt;::value &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="acb2d8087971351c4eb0d25db13ab2c66"></a>typedef typename decay_t&lt; T &gt;<br class="typebreak" />
::Scalar</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d6/d73/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4" id="d6/d73/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::scalar_type&lt; T, std::enable_if_t&lt; is_std_vector&lt; T &gt;::value &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a2ef0cd160de090d3295b5bffd1f976ad"></a>typedef <a class="el" href="../../da/dce/namespacestan.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a><br class="typebreak" />
&lt; typename decay_t&lt; T &gt;<br class="typebreak" />
::<a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type">value_type</a> &gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d1/d30/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4" id="d1/d30/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::value_type&lt; T, std::enable_if_t&lt; is_std_vector&lt; T &gt;::value &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a32ab92bd28e55f1c54981be42d570336"></a>typedef typename decay_t&lt; T &gt;<br class="typebreak" />
::<a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type">value_type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d3/d04/structstan_1_1partials__return__type" id="d3/d04/structstan_1_1partials__return__type"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::partials_return_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab26449cd956d08b69a17c199539a5e6e"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d0/db7/structstan_1_1partials__type" id="d0/db7/structstan_1_1partials__type"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::partials_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="af4ac36cb541ccc64e5e8cb5172adb93b"></a>typedef T</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d0/dc1/structstan_1_1real__return" id="d0/dc1/structstan_1_1real__return"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::real_return</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae3531dbcea6cb1f095ecde305ca7e440"></a>typedef double</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d5/d1d/structstan_1_1scalar__lub" id="d5/d1d/structstan_1_1scalar__lub"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::scalar_lub</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a105f66f663b9c322d1439f1a6f32294d"></a>typedef <a class="el" href="../../d8/de1/group__type__trait.html#ga546483131616701876a9f1307f5a413d">promote_args_t</a>&lt; T1, T2 &gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d8/d68/structstan_1_1return__type" id="d8/d68/structstan_1_1return__type"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::return_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a37cf6c91e22fb14ea60e31c43d651ffc"></a>typedef double</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d6/dd9/structstan_1_1scalar__type" id="d6/dd9/structstan_1_1scalar__type"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::scalar_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a304b5474613917c58a9d878a2c2a45f1"></a>typedef decay_t&lt; T &gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d5/d53/structstan_1_1scalar__type__pre" id="d5/d53/structstan_1_1scalar__type__pre"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::scalar_type_pre</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ad9f18534d39ac716380e37e0881c463f"></a>typedef typename <br class="typebreak" />
scalar_type_helper_pre<br class="typebreak" />
&lt; <a class="el" href="../../d4/d82/structstan_1_1is__vector.html">is_vector</a>&lt; typename <br class="typebreak" />
<a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type">value_type</a>&lt; T &gt;::<a class="el" href="../../d8/de1/group__type__trait.html#ad9f18534d39ac716380e37e0881c463f">type</a> &gt;::value, <br class="typebreak" />
typename <a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type">value_type</a>&lt; T &gt;::<a class="el" href="../../d8/de1/group__type__trait.html#ad9f18534d39ac716380e37e0881c463f">type</a>, <br class="typebreak" />
T &gt;::<a class="el" href="../../d8/de1/group__type__trait.html#ad9f18534d39ac716380e37e0881c463f">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="dd/d27/structstan_1_1value__type" id="dd/d27/structstan_1_1value__type"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="abf156b4d041505279ebc2582b1bceb12"></a>typedef typename decay_t&lt; T &gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="da/d24/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4" id="da/d24/structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::value_type&lt; T, std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a243bad3d2abb1a4aa395c2d87b87d3f2"></a>typedef typename <a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type">value_type</a><br class="typebreak" />
&lt; remove_pointer&lt; T &gt;&gt;::<a class="el" href="../../d8/de1/group__type__trait.html#a243bad3d2abb1a4aa395c2d87b87d3f2">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d6/d3f/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__var_3_01_t_01_4_1_1value_01_4_01_4" id="d6/d3f/structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__var_3_01_t_01_4_1_1value_01_4_01_4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::scalar_type&lt; T, std::enable_if_t&lt; is_var&lt; T &gt;::value &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aec17ccc299d5c4c3d7f52b8488bbefd5"></a>typedef var_value<br class="typebreak" />
&lt; <a class="el" href="../../da/dce/namespacestan.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; typename <br class="typebreak" />
decay_t&lt; T &gt;::<a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type">value_type</a> &gt;&gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d4/da0/structstan_1_1partials__type_3_01_t_00_01require__var__t_3_01_t_01_4_01_4" id="d4/da0/structstan_1_1partials__type_3_01_t_00_01require__var__t_3_01_t_01_4_01_4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct stan::partials_type&lt; T, require_var_t&lt; T &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a26e18c3b2e97cb517347728faba59f84"></a>typedef typename decay_t&lt; T &gt;<br class="typebreak" />
::<a class="el" href="../../d8/de1/group__type__trait.html#dd/d27/structstan_1_1value__type">value_type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gad1046e42476333dc3c08c35bfe420302"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gad1046e42476333dc3c08c35bfe420302">stan::bool_constant</a> = typedef std::integral_constant&lt;bool, B&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for structs used for wraps a static constant of bool. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B</td><td>On true, inherits std::true_type, false is std::false_type </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d6/dfd/bool__constant_8hpp_source.html#l00012">12</a> of file <a class="el" href="../../d6/dfd/bool__constant_8hpp_source.html">bool_constant.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga6c52a0fffdfffc70123211cead9c7dbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga6c52a0fffdfffc70123211cead9c7dbf">stan::complex_return_t</a> = typedef std::complex&lt;real_return_t&lt;Ts...&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type to calculate the complex return type, which wraps <code>std::complex</code> around the return type of the specified template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/de1/group__type__trait.html#d0/dc1/structstan_1_1real__return" title="Provides a member type alias named type, the value of which is the least type under Stan&#39;s assignabil...">real_return</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00057">57</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga76542442910faefbee636785a9f34091"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga76542442910faefbee636785a9f34091">stan::contains_fvar</a> = typedef math::disjunction&lt;is_fvar&lt;scalar_type_t&lt;T&gt;&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends std::true_type when instantiated with at least 1 template parameter that is a fvar. </p>
<p>Extends std::false_type otherwise. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Types to test </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../da/d10/contains__fvar_8hpp_source.html#l00017">17</a> of file <a class="el" href="../../da/d10/contains__fvar_8hpp_source.html">contains_fvar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaaa1b1eb615a4b1b30b46ef33ace88cdf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gaaa1b1eb615a4b1b30b46ef33ace88cdf">stan::contains_std_vector</a> = typedef math::disjunction&lt;is_std_vector&lt;Ts&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if any types are std vectors. </p>

<p>Definition at line <a class="el" href="../../de/dc9/contains__std__vector_8hpp_source.html#l00014">14</a> of file <a class="el" href="../../de/dc9/contains__std__vector_8hpp_source.html">contains_std_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga880b82cbb2b83ccaba2426e73996b8bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga880b82cbb2b83ccaba2426e73996b8bd">stan::is_constant_all</a> = typedef math::conjunction&lt;is_constant&lt;T&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metaprogram defining an enum <code>value</code> which is <code>true</code> if all of the type parameters are constant (i.e., primitive types) and <code>false</code> otherwise. </p>

<p>Definition at line <a class="el" href="../../da/d53/prim_2meta_2is__constant_8hpp_source.html#l00039">39</a> of file <a class="el" href="../../da/d53/prim_2meta_2is__constant_8hpp_source.html">is_constant.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7feafa1620b2760383a7857b2fc2e2c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga7feafa1620b2760383a7857b2fc2e2c0">stan::is_dense_dynamic</a> = typedef internal::is_dense_dynamic_impl&lt;std::decay_t&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether type T is derived from Eigen::DenseBase and has dynamic rows and columns or is a <code>var_value&lt;&gt;</code> whose inner type satisfies the conditions above. </p>
<p>If true this will have a static member function named value with a type of true, else value is false. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to check </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d0/dab/is__dense__dynamic_8hpp_source.html#l00039">39</a> of file <a class="el" href="../../d0/dab/is__dense__dynamic_8hpp_source.html">is_dense_dynamic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga5ba4b41c5d4073b73b794ba0f51b416d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga5ba4b41c5d4073b73b794ba0f51b416d">stan::is_eigen_dense_dynamic</a> = typedef <a class="el" href="../../d3/d5e/structstan_1_1internal_1_1is__eigen__matrix__dynamic__impl.html">stan::internal::is_eigen_matrix_dynamic_impl</a>&lt; std::decay_t&lt;T&gt;, <a class="el" href="../../da/dbf/structstan_1_1is__eigen__dense__base.html">stan::is_eigen_dense_base</a>&lt;std::decay_t&lt;T&gt;&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether type T is derived from Eigen::DenseBase and has dynamic rows and columns. </p>
<p>If true this will have a static member function named value with a type of true, else value is false. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to check </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d7/da8/is__eigen__dense__dynamic_8hpp_source.html#l00023">23</a> of file <a class="el" href="../../d7/da8/is__eigen__dense__dynamic_8hpp_source.html">is_eigen_dense_dynamic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga785a5342448197bf621913e8295b2748"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga785a5342448197bf621913e8295b2748">stan::is_eigen_matrix_or_array</a> = typedef math::disjunction&lt;is_eigen_matrix_base&lt;T&gt;, is_eigen_array&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a type is derived from <code>Eigen::MatrixBase</code> or <code>Eigen::ArrayBase</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to check. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d8/dd8/is__eigen_8hpp_source.html#l00069">69</a> of file <a class="el" href="../../d8/dd8/is__eigen_8hpp_source.html">is_eigen.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga3cedb8a7f6d2c46ed31fc8e49710d74b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga3cedb8a7f6d2c46ed31fc8e49710d74b">stan::is_plain_type</a> = typedef std::is_same&lt;std::decay_t&lt;S&gt;, plain_type_t&lt;S&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the template type <code>T</code> is an assignable type. </p>
<p>This is used to detect whether a type is an <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix expression. </p>

<p>Definition at line <a class="el" href="../../d6/dcd/is__plain__type_8hpp_source.html#l00014">14</a> of file <a class="el" href="../../d6/dcd/is__plain__type_8hpp_source.html">is_plain_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga0f2252ae22390725feb09d9ea11b7896"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga0f2252ae22390725feb09d9ea11b7896">stan::is_string_convertible</a> = typedef std::is_convertible&lt;T, std::string&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduces whether type is convertible to string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to check </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dc/d4f/is__string__convertible_8hpp_source.html#l00016">16</a> of file <a class="el" href="../../dc/d4f/is__string__convertible_8hpp_source.html">is_string_convertible.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9d36a4d6158f96c2321b4fbf55243ca8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga9d36a4d6158f96c2321b4fbf55243ca8">stan::is_var_or_arithmetic</a> = typedef math::conjunction&lt;is_var_or_arithmetic_type&lt;T&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends std::true_type if all the provided types are either var or an arithmetic type, extends std::false_type otherwise. </p>

<p>Definition at line <a class="el" href="../../d7/dfe/is__var__or__arithmetic_8hpp_source.html#l00030">30</a> of file <a class="el" href="../../d7/dfe/is__var__or__arithmetic_8hpp_source.html">is_var_or_arithmetic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gab3412a1caaad7f8eef55a9ee2a0d3921"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gab3412a1caaad7f8eef55a9ee2a0d3921">stan::matrix_return_t</a> = typedef Eigen::Matrix&lt;real_return_t&lt;Ts...&gt;, -1, -1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , -1, -1&gt;</code> around the return type of the specified template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/de1/group__type__trait.html#d0/dc1/structstan_1_1real__return" title="Provides a member type alias named type, the value of which is the least type under Stan&#39;s assignabil...">real_return</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00080">80</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga1310fb459dbad72fa5594b6d1eaad959"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga1310fb459dbad72fa5594b6d1eaad959">stan::partials_type_t</a> = typedef typename partials_type&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper alias for accessing the partial type. </p>

<p>Definition at line <a class="el" href="../../dd/d43/prim_2meta_2partials__type_8hpp_source.html#l00020">20</a> of file <a class="el" href="../../dd/d43/prim_2meta_2partials__type_8hpp_source.html">partials_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga546483131616701876a9f1307f5a413d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga546483131616701876a9f1307f5a413d">stan::promote_args_t</a> = typedef typename boost::math::tools::promote_args&lt;Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience alias for boost tools promote_args. </p>

<p>Definition at line <a class="el" href="../../de/d54/promote__args_8hpp_source.html#l00012">12</a> of file <a class="el" href="../../de/d54/promote__args_8hpp_source.html">promote_args.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gac9d3fe14d5102916bf0b5b05712c833e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">stan::real_return_t</a> = typedef typename real_return&lt;Ts...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type to calculate the real return type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/de1/group__type__trait.html#d0/dc1/structstan_1_1real__return" title="Provides a member type alias named type, the value of which is the least type under Stan&#39;s assignabil...">real_return</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00046">46</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gacbaff683cd2683209e6855e2c7aaeffe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a> = typedef typename return_type&lt;Ts...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type for the return type of the specified template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/de1/group__type__trait.html#d8/d68/structstan_1_1return__type" title="Template metaprogram to calculate the base scalar return type resulting from promoting all the scalar...">return_type</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00206">206</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga2fa4e21b37c08e6abce2919ac4c2cd57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga2fa4e21b37c08e6abce2919ac4c2cd57">stan::row_vector_return_t</a> = typedef Eigen::Matrix&lt;real_return_t&lt;Ts...&gt;, 1, -1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , 1, -1&gt;</code> around the return type of the specified template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/de1/group__type__trait.html#d0/dc1/structstan_1_1real__return" title="Provides a member type alias named type, the value of which is the least type under Stan&#39;s assignabil...">real_return</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00104">104</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gace9d2d5da99a3e14fcadd7bf0f6cffee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gace9d2d5da99a3e14fcadd7bf0f6cffee">stan::scalar_lub_t</a> = typedef typename scalar_lub&lt;T1, T2&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type for the least upper bound of the specified template parameters in Stan's assignment ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T1</td><td>first type </td></tr>
    <tr><td class="paramname">T2</td><td>second type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/de1/group__type__trait.html#d5/d1d/structstan_1_1scalar__lub" title="Defines a member type named type that is the least scalar type to which both template parameter scala...">scalar_lub</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00147">147</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaad4ed0103c48143e708de631fbb83a7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gaad4ed0103c48143e708de631fbb83a7f">stan::std_vector_return_t</a> = typedef std::vector&lt;real_return_t&lt;Ts...&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type to calculate the complex return type, which wraps <code>std::vector</code> around the return type of the specified template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/de1/group__type__trait.html#d0/dc1/structstan_1_1real__return" title="Provides a member type alias named type, the value of which is the least type under Stan&#39;s assignabil...">real_return</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00068">68</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga57121ded0440567e8dfb0d80b1290922"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">stan::value_type_t</a> = typedef typename value_type&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for accessing underlying type. </p>

<p>Definition at line <a class="el" href="../../df/dd4/prim_2meta_2value__type_8hpp_source.html#l00035">35</a> of file <a class="el" href="../../df/dd4/prim_2meta_2value__type_8hpp_source.html">value_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga1b070b6ae219eccccf07b44243307b8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga1b070b6ae219eccccf07b44243307b8b">stan::vector_return_t</a> = typedef Eigen::Matrix&lt;real_return_t&lt;Ts...&gt;, -1, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , -1, 1&gt;</code> around the return type of the specified template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/de1/group__type__trait.html#d0/dc1/structstan_1_1real__return" title="Provides a member type alias named type, the value of which is the least type under Stan&#39;s assignabil...">real_return</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00092">92</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae29786dab3b9274d3f1d08f6904854eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op1 , typename Op2 , typename Op3 , typename Op4 , typename Op5 , typename Dx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_return_type <a class="el" href="../../da/dd1/classstan_1_1math_1_1operands__and__partials.html">stan::math::operands_and_partials</a>&lt; Op1, Op2, Op3, Op4, Op5, fvar&lt; Dx &gt; &gt;::build </td>
          <td>(</td>
          <td class="paramtype">Dx&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the node to be stored on the autodiff graph. </p>
<p>This should contain both the value and the tangent.</p>
<p>For scalars, we don't calculate any tangents. For reverse mode, we end up returning a type of var that will calculate the appropriate adjoint using the stored operands and partials. Forward mode just calculates the tangent on the spot and returns it in a vanilla fvar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the return value of the function we are compressing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value with its derivative </dd></dl>

<p>Definition at line <a class="el" href="../../da/d8e/fwd_2functor_2operands__and__partials_8hpp_source.html#l00104">104</a> of file <a class="el" href="../../da/d8e/fwd_2functor_2operands__and__partials_8hpp_source.html">operands_and_partials.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gacd89dca2a48f398e759d882af2e62ddd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op1 , typename Op2 , typename Op3 , typename Op4 , typename Op5 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">var <a class="el" href="../../da/dd1/classstan_1_1math_1_1operands__and__partials.html">stan::math::operands_and_partials</a>&lt; Op1, Op2, Op3, Op4, Op5, var &gt;::build </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the node to be stored on the autodiff graph. </p>
<p>This should contain both the value and the tangent.</p>
<p>For scalars, we don't calculate any tangents. For reverse mode, we end up returning a type of var that will calculate the appropriate adjoint using the stored operands and partials. Forward mode just calculates the tangent on the spot and returns it in a vanilla fvar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the return value of the function we are compressing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node to be stored in the expression graph for autodiff </dd></dl>

<p>Definition at line <a class="el" href="../../d9/d00/rev_2functor_2operands__and__partials_8hpp_source.html#l00117">117</a> of file <a class="el" href="../../d9/d00/rev_2functor_2operands__and__partials_8hpp_source.html">operands_and_partials.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga1a1f786a0f0544b5b9b10800518fa161"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op1, typename Op2, typename Op3, typename Op4, typename Op5, typename T_return_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_return_type <a class="el" href="../../da/dd1/classstan_1_1math_1_1operands__and__partials.html">stan::math::operands_and_partials</a>&lt; Op1, Op2, Op3, Op4, Op5, T_return_type &gt;::build </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the node to be stored on the autodiff graph. </p>
<p>This should contain both the value and the tangent.</p>
<p>For scalars (this implementation), we don't calculate any derivatives. For reverse mode, we end up returning a type of var that will calculate the appropriate adjoint using the stored operands and partials. Forward mode just calculates the tangent on the spot and returns it in a vanilla fvar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the return value of the function we are compressing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value with its derivative </dd></dl>

<p>Definition at line <a class="el" href="../../d8/d0c/prim_2functor_2operands__and__partials_8hpp_source.html#l00123">123</a> of file <a class="el" href="../../d8/d0c/prim_2functor_2operands__and__partials_8hpp_source.html">operands_and_partials.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga354e6529ea257ab6475be87e7c217ce9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::col </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented so cannot be called. </p>

</div>
</div>
<a class="anchor" id="ga0af4c158839e8c4c401e0f7e78bb4dc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;std::is_same&lt;std::decay_t&lt;T_actual&gt;,                                          std::decay_t&lt;T_desired&gt;&gt;::value                             &amp;&amp; !is_eigen&lt;T_desired&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_actual&amp;&amp; stan::math::forward_as </td>
          <td>(</td>
          <td class="paramtype">T_actual &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assume which type we get. </p>
<p>If actual type is convertible to assumed type or in case of eigen types compile time rows and columns also match or desired sizes are dynamic this is a no-op. Otherwise it throws std::runtime_error, which should never happen if used as intended.</p>
<p>This is intended to be used in compile time branches that would otherwise trigger compile error even though they are never executed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_desired</td><td>type of output we need to avoid compile time errors </td></tr>
    <tr><td class="paramname">T_actual</td><td>actual type of the argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input value a </dd></dl>

<p>Definition at line <a class="el" href="../../d1/df7/forward__as_8hpp_source.html#l00037">37</a> of file <a class="el" href="../../d1/df7/forward__as_8hpp_source.html">forward_as.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga6cc77bba018fff06dd1f0f0f2d79e5b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;              !std::is_same&lt;std::decay&lt;T_actual&gt;, std::decay&lt;T_desired&gt;&gt;::value              &amp;&amp; (!is_eigen&lt;T_desired&gt;::value || !is_eigen&lt;T_actual&gt;::value)&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_desired stan::math::forward_as </td>
          <td>(</td>
          <td class="paramtype">const T_actual &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assume which type we get. </p>
<p>If actual type is not convertible to assumed type or in case of eigen types compile time rows and columns are not the same and desired sizes are not dynamic this has return type of <code>T_desired</code>, but it only throws. This version should only be used where it is optimized away so the throw should never happen.</p>
<p>This is intended to be used in compile time branches that would otherwise trigger compile error even though they are never executed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_desired</td><td>type of output we need to avoid compile time errors </td></tr>
    <tr><td class="paramname">T_actual</td><td>actual type of the argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing, this always throws </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">always</td><td>throws std::runtime_error </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d1/df7/forward__as_8hpp_source.html#l00061">61</a> of file <a class="el" href="../../d1/df7/forward__as_8hpp_source.html">forward_as.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga385d807274aa40985a59c273d49cf9cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_desired , typename T_actual , require_eigen_t&lt; T_desired &gt; *  = nullptr, std::enable_if_t&lt; std::is_same&lt; value_type_t&lt; T_actual &gt;, value_type_t&lt; T_desired &gt;&gt;::value &amp;&amp;is_eigen&lt; T_desired &gt;::value &amp;&amp;is_eigen&lt; T_actual &gt;::value &amp;&amp;internal::eigen_static_size_match(T_desired::RowsAtCompileTime, std::decay_t&lt; T_actual &gt;::RowsAtCompileTime)&amp;&amp;internal::eigen_static_size_match(T_desired::ColsAtCompileTime, std::decay_t&lt; T_actual &gt;::ColsAtCompileTime)&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_actual&amp;&amp; stan::math::forward_as </td>
          <td>(</td>
          <td class="paramtype">T_actual &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assume which type we get. </p>
<p>If actual type is convertible to assumed type or in case of eigen types compile time rows and columns also match or desired sizes are dynamic this is a no-op. Otherwise it throws std::runtime_error, which should never happen if used as intended.</p>
<p>This is intended to be used in compile time branches that would otherwise trigger compile error even though they are never executed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_desired</td><td>type of output we need to avoid compile time errors </td></tr>
    <tr><td class="paramname">T_actual</td><td>actual type of the argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input value a </dd></dl>

<p>Definition at line <a class="el" href="../../d1/df7/forward__as_8hpp_source.html#l00091">91</a> of file <a class="el" href="../../d1/df7/forward__as_8hpp_source.html">forward_as.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gad2a93cdd718b76d4994d0f7c6c05fbba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_stan_scalar_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::get </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the provided element. </p>
<p>Scalar type overload for the function to retrieve n-th element of a vector, <code><a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a></code> <code>Matrix</code> or expression</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input scalar </td></tr>
    <tr><td class="paramname">n</td><td>index of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input scalar </dd></dl>

<p>Definition at line <a class="el" href="../../dc/d95/get_8hpp_source.html#l00023">23</a> of file <a class="el" href="../../dc/d95/get_8hpp_source.html">get.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga431bd201f09a215cccb16cda10a1e840"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::get </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the n-th element of the provided std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input vector </td></tr>
    <tr><td class="paramname">n</td><td>index of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n-th element of the input vector </dd></dl>

<p>Definition at line <a class="el" href="../../dc/d95/get_8hpp_source.html#l00035">35</a> of file <a class="el" href="../../dc/d95/get_8hpp_source.html">get.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga80a702889907a3c12704df6c514fcc07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ViewElt&amp; <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented so cannot be called. </p>

</div>
</div>
<a class="anchor" id="ga84d157dabee552a681aa5e4406b86474"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d19/classstan_1_1math_1_1internal_1_1empty__broadcast__array_3_01_view_elt_00_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#ae60f68cce56bd8855479f31c9d37ca50">T_arg</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented so cannot be called. </p>

</div>
</div>
<a class="anchor" id="ga50070330d69c12c87811fcaf4e643803"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d19/classstan_1_1math_1_1internal_1_1empty__broadcast__array_3_01_view_elt_00_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#ae60f68cce56bd8855479f31c9d37ca50">T_arg</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented so cannot be called. </p>

</div>
</div>
<a class="anchor" id="ga9b28065e82cdcee1c320a7120cb8a83d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d5/dbd/classstan_1_1math_1_1internal_1_1broadcast__array.html">stan::math::internal::broadcast_array</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast array can be assigned a scalar or a vector. </p>
<p>If assigned a scalar, it will be used directly. If assigned a vector, the argument will be summed first. </p>

<p>Definition at line <a class="el" href="../../d4/df8/broadcast__array_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../d4/df8/broadcast__array_8hpp_source.html">broadcast_array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga390dff20f30679c8e57ca2c3efe6d766"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename S, typename Enable = void&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; T, S, Enable &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented so cannot be called. </p>

</div>
</div>
<a class="anchor" id="ga501ec44e68851a8396f5f693e35a2e69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d19/classstan_1_1math_1_1internal_1_1empty__broadcast__array_3_01_view_elt_00_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#ae60f68cce56bd8855479f31c9d37ca50">T_arg</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented so cannot be called. </p>

</div>
</div>
<a class="anchor" id="ga0bc34a86c0bb1a9853b36aa4c952a4dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename S, typename Enable = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; T, S, Enable &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented so cannot be called. </p>

</div>
</div>
<a class="anchor" id="gaf06037332423259c9f5fa57c9b72ad3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ViewElt&amp; <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented so cannot be called. </p>

</div>
</div>
<a class="anchor" id="ga8fd58c5861f0ee94465a97f78b2a00f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::row </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented so cannot be called. </p>

</div>
</div>
<a class="anchor" id="ga98afb6ae5281b82b30caa793e205f6ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size (number of the elements) of a <code><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a></code> or <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt;<a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>&lt;T&gt;&gt;</code>. </p>
<p>Returns the size of the provided <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix, expression or std::vector.</p>
<p>Returns the length of primitive scalar types that are always of length 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>input to determine size of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements in m</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>input <code><a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a></code> <code>Matrix</code>, expression or std::vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of m </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../de/df3/opencl_2prim_2size_8hpp_source.html#l00018">18</a> of file <a class="el" href="../../de/df3/opencl_2prim_2size_8hpp_source.html">size.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gab9a1e2f6c725ab45a9a0d5335ae9b0c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarT , require_stan_scalar_t&lt; ScalarT &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::size_mvt </td>
          <td>(</td>
          <td class="paramtype">const ScalarT &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the size of a multivariate argument. </p>
<p>This is the default template function. For any scalar type, this will throw an std::invalid_argument exception since a scalar is not a multivariate structure.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to take size of. The default template function should only match scalars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>since the type is a scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d2/da6/size__mvt_8hpp_source.html#l00024">24</a> of file <a class="el" href="../../d2/da6/size__mvt_8hpp_source.html">size_mvt.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
