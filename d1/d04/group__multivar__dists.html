<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: Multivariate Distributions</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../$standoxy.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">4.0.1</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d1/d04/group__multivar__dists.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Multivariate Distributions<div class="ingroups"><a class="el" href="../../d5/db4/group__prob__dists.html">Probability Distributions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Distributions with Matrix inputs. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga25d3a0c1398ed337c7979559b1156727"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:ga25d3a0c1398ed337c7979559b1156727"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga25d3a0c1398ed337c7979559b1156727">stan::math::bernoulli_logit_glm_log</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;beta)</td></tr>
<tr class="separator:ga25d3a0c1398ed337c7979559b1156727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa134b4fd02e5d004766d37732e7801b4"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:gaa134b4fd02e5d004766d37732e7801b4"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gaa134b4fd02e5d004766d37732e7801b4">stan::math::bernoulli_logit_glm_log</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;beta)</td></tr>
<tr class="separator:gaa134b4fd02e5d004766d37732e7801b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae708042f23d9a65b9b9d62c41b9c5e8f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , require_eigen_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae708042f23d9a65b9b9d62c41b9c5e8f"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gae708042f23d9a65b9b9d62c41b9c5e8f">stan::math::bernoulli_logit_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;beta)</td></tr>
<tr class="memdesc:gae708042f23d9a65b9b9d62c41b9c5e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Bernoulli distribution and logit link function.  <a href="../../d1/d04/group__multivar__dists.html#gae708042f23d9a65b9b9d62c41b9c5e8f">More...</a><br /></td></tr>
<tr class="separator:gae708042f23d9a65b9b9d62c41b9c5e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga305e57f094bad826b293179514f1c7b8"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_alpha , typename T_beta , class RNG &gt; </td></tr>
<tr class="memitem:ga305e57f094bad826b293179514f1c7b8"><td class="memTemplItemLeft" align="right" valign="top">VectorBuilder&lt; true, int, T_alpha &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga305e57f094bad826b293179514f1c7b8">stan::math::bernoulli_logit_glm_rng</a> (const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;beta, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga305e57f094bad826b293179514f1c7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a draw from the Generalized Linear Model (GLM) with Bernoulli distribution and logit link function.  <a href="../../d1/d04/group__multivar__dists.html#ga305e57f094bad826b293179514f1c7b8">More...</a><br /></td></tr>
<tr class="separator:ga305e57f094bad826b293179514f1c7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59609a885c7799e09536dfaac422408d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:ga59609a885c7799e09536dfaac422408d"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga59609a885c7799e09536dfaac422408d">stan::math::categorical_log</a> (const T_n &amp;ns, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga59609a885c7799e09536dfaac422408d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f9fccab8df853934c6e093ed07562d1"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:ga4f9fccab8df853934c6e093ed07562d1"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga4f9fccab8df853934c6e093ed07562d1">stan::math::categorical_log</a> (const T_n &amp;ns, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga4f9fccab8df853934c6e093ed07562d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17b9cdb8336f173a13db846c509e5412"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , require_eigen_t&lt; T_x &gt; *  = nullptr, require_eigen_col_vector_t&lt; T_alpha &gt; *  = nullptr, require_eigen_matrix_dynamic_t&lt; T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga17b9cdb8336f173a13db846c509e5412"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga17b9cdb8336f173a13db846c509e5412">stan::math::categorical_logit_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;beta)</td></tr>
<tr class="memdesc:ga17b9cdb8336f173a13db846c509e5412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with categorical distribution and logit (softmax) link function.  <a href="../../d1/d04/group__multivar__dists.html#ga17b9cdb8336f173a13db846c509e5412">More...</a><br /></td></tr>
<tr class="separator:ga17b9cdb8336f173a13db846c509e5412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9baba3b60a4d1e78c1ab36d797d36cc"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:gaa9baba3b60a4d1e78c1ab36d797d36cc"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gaa9baba3b60a4d1e78c1ab36d797d36cc">stan::math::categorical_logit_log</a> (const T_n &amp;ns, const T_prob &amp;beta)</td></tr>
<tr class="separator:gaa9baba3b60a4d1e78c1ab36d797d36cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga801751852f64866699bcf2242813c026"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:ga801751852f64866699bcf2242813c026"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga801751852f64866699bcf2242813c026">stan::math::categorical_logit_log</a> (const T_n &amp;ns, const T_prob &amp;beta)</td></tr>
<tr class="separator:ga801751852f64866699bcf2242813c026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga735693bdf47c855697175ca6f5698929"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ga735693bdf47c855697175ca6f5698929"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga735693bdf47c855697175ca6f5698929">stan::math::categorical_logit_rng</a> (const Eigen::VectorXd &amp;beta, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga735693bdf47c855697175ca6f5698929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a draw from a Categorical distribution given a a vector of unnormalized log probabilities and a psuedo-random number generator.  <a href="../../d1/d04/group__multivar__dists.html#ga735693bdf47c855697175ca6f5698929">More...</a><br /></td></tr>
<tr class="separator:ga735693bdf47c855697175ca6f5698929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3d5bb184fcb8329ec0b157ef7845321"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob , typename T_prior_size &gt; </td></tr>
<tr class="memitem:gae3d5bb184fcb8329ec0b157ef7845321"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_prob, T_prior_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gae3d5bb184fcb8329ec0b157ef7845321">stan::math::dirichlet_log</a> (const T_prob &amp;theta, const T_prior_size &amp;alpha)</td></tr>
<tr class="memdesc:gae3d5bb184fcb8329ec0b157ef7845321"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Dirichlet density for the given theta and a vector of prior sample sizes, alpha.  <a href="../../d1/d04/group__multivar__dists.html#gae3d5bb184fcb8329ec0b157ef7845321">More...</a><br /></td></tr>
<tr class="separator:gae3d5bb184fcb8329ec0b157ef7845321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa63ffb06e9e808dda50ee7494e25b7"><td class="memTemplParams" colspan="2">template&lt;typename T_prob , typename T_prior_size &gt; </td></tr>
<tr class="memitem:ga1aa63ffb06e9e808dda50ee7494e25b7"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_prob, T_prior_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga1aa63ffb06e9e808dda50ee7494e25b7">stan::math::dirichlet_log</a> (const T_prob &amp;theta, const T_prior_size &amp;alpha)</td></tr>
<tr class="separator:ga1aa63ffb06e9e808dda50ee7494e25b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga993200aac080067864439bb59dc12bd4"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob , typename T_prior_size , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_prob, T_prior_size &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga993200aac080067864439bb59dc12bd4"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_prob, T_prior_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga993200aac080067864439bb59dc12bd4">stan::math::dirichlet_lpdf</a> (const T_prob &amp;theta, const T_prior_size &amp;alpha)</td></tr>
<tr class="memdesc:ga993200aac080067864439bb59dc12bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Dirichlet density for the given theta and a vector of prior sample sizes, alpha.  <a href="../../d1/d04/group__multivar__dists.html#ga993200aac080067864439bb59dc12bd4">More...</a><br /></td></tr>
<tr class="separator:ga993200aac080067864439bb59dc12bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56d91749cc27fb49662ff50e1112ef9f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob , typename T_prior_size &gt; </td></tr>
<tr class="memitem:ga56d91749cc27fb49662ff50e1112ef9f"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_prob, T_prior_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga56d91749cc27fb49662ff50e1112ef9f">stan::math::dirichlet_lpmf</a> (const T_prob &amp;theta, const T_prior_size &amp;alpha)</td></tr>
<tr class="separator:ga56d91749cc27fb49662ff50e1112ef9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb288324f889b7da57f2960570f459ea"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:gacb288324f889b7da57f2960570f459ea"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gacb288324f889b7da57f2960570f459ea">stan::math::dirichlet_rng</a> (const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;alpha, RNG &amp;rng)</td></tr>
<tr class="memdesc:gacb288324f889b7da57f2960570f459ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a draw from a Dirichlet distribution with specified parameters and pseudo-random number generator.  <a href="../../d1/d04/group__multivar__dists.html#gacb288324f889b7da57f2960570f459ea">More...</a><br /></td></tr>
<tr class="separator:gacb288324f889b7da57f2960570f459ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86f952dd3635d180de80428f9350a35b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 &gt; </td></tr>
<tr class="memitem:ga86f952dd3635d180de80428f9350a35b"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_F, T_G, T_V, T_W, T_m0, T_C0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga86f952dd3635d180de80428f9350a35b">stan::math::gaussian_dlm_obs_log</a> (const T_y &amp;y, const T_F &amp;F, const T_G &amp;G, const T_V &amp;V, const T_W &amp;W, const T_m0 &amp;m0, const T_C0 &amp;C0)</td></tr>
<tr class="separator:ga86f952dd3635d180de80428f9350a35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b1ca42a98c13529b45c3ca2af0b75c3"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 &gt; </td></tr>
<tr class="memitem:ga9b1ca42a98c13529b45c3ca2af0b75c3"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_F, T_G, T_V, T_W, T_m0, T_C0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga9b1ca42a98c13529b45c3ca2af0b75c3">stan::math::gaussian_dlm_obs_log</a> (const T_y &amp;y, const T_F &amp;F, const T_G &amp;G, const T_V &amp;V, const T_W &amp;W, const T_m0 &amp;m0, const T_C0 &amp;C0)</td></tr>
<tr class="separator:ga9b1ca42a98c13529b45c3ca2af0b75c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa04df98134e973d4d3ce2e6ba814b18a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 , require_all_eigen_matrix_dynamic_t&lt; T_y, T_F, T_G, T_V, T_W, T_C0 &gt; *  = nullptr, require_eigen_col_vector_t&lt; T_m0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa04df98134e973d4d3ce2e6ba814b18a"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_F, T_G, T_V, T_W, T_m0, T_C0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gaa04df98134e973d4d3ce2e6ba814b18a">stan::math::gaussian_dlm_obs_lpdf</a> (const T_y &amp;y, const T_F &amp;F, const T_G &amp;G, const T_V &amp;V, const T_W &amp;W, const T_m0 &amp;m0, const T_C0 &amp;C0)</td></tr>
<tr class="memdesc:gaa04df98134e973d4d3ce2e6ba814b18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a Gaussian dynamic linear model (GDLM).  <a href="../../d1/d04/group__multivar__dists.html#gaa04df98134e973d4d3ce2e6ba814b18a">More...</a><br /></td></tr>
<tr class="separator:gaa04df98134e973d4d3ce2e6ba814b18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad26dd2ec37297ebe230eadae53025d19"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:gad26dd2ec37297ebe230eadae53025d19"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gad26dd2ec37297ebe230eadae53025d19">stan::math::internal::multi_normal_semidefinite_rng</a> (const Eigen::VectorXd &amp;mu, const Eigen::LDLT&lt; Eigen::MatrixXd &gt; &amp;S_ldlt, RNG &amp;rng)</td></tr>
<tr class="memdesc:gad26dd2ec37297ebe230eadae53025d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a multivariate normal random variate with the given location and covariance using the specified random number generator.  <a href="../../d1/d04/group__multivar__dists.html#gad26dd2ec37297ebe230eadae53025d19">More...</a><br /></td></tr>
<tr class="separator:gad26dd2ec37297ebe230eadae53025d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38ce72e12b0f414f6c82f82f492db728"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ga38ce72e12b0f414f6c82f82f492db728"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga38ce72e12b0f414f6c82f82f492db728">stan::math::gaussian_dlm_obs_rng</a> (const Eigen::MatrixXd &amp;F, const Eigen::MatrixXd &amp;G, const Eigen::MatrixXd &amp;V, const Eigen::MatrixXd &amp;W, const Eigen::VectorXd &amp;m0, const Eigen::MatrixXd &amp;C0, const int T, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga38ce72e12b0f414f6c82f82f492db728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate random draw from Gaussian dynamic linear model (GDLM).  <a href="../../d1/d04/group__multivar__dists.html#ga38ce72e12b0f414f6c82f82f492db728">More...</a><br /></td></tr>
<tr class="separator:ga38ce72e12b0f414f6c82f82f492db728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40f6b9636708f5cf52428890f2b62c2"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:gaa40f6b9636708f5cf52428890f2b62c2"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gaa40f6b9636708f5cf52428890f2b62c2">stan::math::inv_wishart_log</a> (const T_y &amp;W, const T_dof &amp;nu, const T_scale &amp;S)</td></tr>
<tr class="memdesc:gaa40f6b9636708f5cf52428890f2b62c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Inverse-Wishart density for the given W, degrees of freedom, and scale matrix.  <a href="../../d1/d04/group__multivar__dists.html#gaa40f6b9636708f5cf52428890f2b62c2">More...</a><br /></td></tr>
<tr class="separator:gaa40f6b9636708f5cf52428890f2b62c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b83a2e763ad50ebace73c003cdffee2"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:ga7b83a2e763ad50ebace73c003cdffee2"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga7b83a2e763ad50ebace73c003cdffee2">stan::math::inv_wishart_log</a> (const T_y &amp;W, const T_dof &amp;nu, const T_scale &amp;S)</td></tr>
<tr class="separator:ga7b83a2e763ad50ebace73c003cdffee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bab1543379d2e07160d395b2e0a832c"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:ga3bab1543379d2e07160d395b2e0a832c"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga3bab1543379d2e07160d395b2e0a832c">stan::math::inv_wishart_lpdf</a> (const T_y &amp;W, const T_dof &amp;nu, const T_scale &amp;S)</td></tr>
<tr class="memdesc:ga3bab1543379d2e07160d395b2e0a832c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Inverse-Wishart density for the given W, degrees of freedom, and scale matrix.  <a href="../../d1/d04/group__multivar__dists.html#ga3bab1543379d2e07160d395b2e0a832c">More...</a><br /></td></tr>
<tr class="separator:ga3bab1543379d2e07160d395b2e0a832c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4f34ffe4fb4185f64f05b28899bf1be"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_covar , typename T_shape &gt; </td></tr>
<tr class="memitem:gad4f34ffe4fb4185f64f05b28899bf1be"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_covar, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gad4f34ffe4fb4185f64f05b28899bf1be">stan::math::lkj_corr_cholesky_log</a> (const T_covar &amp;L, const T_shape &amp;eta)</td></tr>
<tr class="separator:gad4f34ffe4fb4185f64f05b28899bf1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf932f9050e5cd92af767842e35978ec9"><td class="memTemplParams" colspan="2">template&lt;typename T_covar , typename T_shape &gt; </td></tr>
<tr class="memitem:gaf932f9050e5cd92af767842e35978ec9"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_covar, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gaf932f9050e5cd92af767842e35978ec9">stan::math::lkj_corr_cholesky_log</a> (const T_covar &amp;L, const T_shape &amp;eta)</td></tr>
<tr class="separator:gaf932f9050e5cd92af767842e35978ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42a03d6d4728db20bc6ba51f6890004f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape &gt; </td></tr>
<tr class="memitem:ga42a03d6d4728db20bc6ba51f6890004f"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga42a03d6d4728db20bc6ba51f6890004f">stan::math::lkj_corr_log</a> (const T_y &amp;y, const T_shape &amp;eta)</td></tr>
<tr class="separator:ga42a03d6d4728db20bc6ba51f6890004f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae537974c3f5c4d51df02883faf940514"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape &gt; </td></tr>
<tr class="memitem:gae537974c3f5c4d51df02883faf940514"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gae537974c3f5c4d51df02883faf940514">stan::math::lkj_corr_log</a> (const T_y &amp;y, const T_shape &amp;eta)</td></tr>
<tr class="separator:gae537974c3f5c4d51df02883faf940514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5570fda8e3d07213840dc2a9f4155e18"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ga5570fda8e3d07213840dc2a9f4155e18"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga5570fda8e3d07213840dc2a9f4155e18">stan::math::lkj_corr_rng</a> (size_t K, double eta, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga5570fda8e3d07213840dc2a9f4155e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random correlation matrix (symmetric, positive definite, unit diagonal) of the specified dimensionality drawn from the LKJ distribution with the specified degrees of freedom using the specified random number generator.  <a href="../../d1/d04/group__multivar__dists.html#ga5570fda8e3d07213840dc2a9f4155e18">More...</a><br /></td></tr>
<tr class="separator:ga5570fda8e3d07213840dc2a9f4155e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf76c55d89307f751df515b9b11df006c"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:gaf76c55d89307f751df515b9b11df006c"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gaf76c55d89307f751df515b9b11df006c">stan::math::lkj_cov_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;eta)</td></tr>
<tr class="separator:gaf76c55d89307f751df515b9b11df006c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1263a19d3a44357832c1baafe3fb4df2"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ga1263a19d3a44357832c1baafe3fb4df2"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga1263a19d3a44357832c1baafe3fb4df2">stan::math::lkj_cov_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;eta)</td></tr>
<tr class="separator:ga1263a19d3a44357832c1baafe3fb4df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64262a3799093d51c79227c7ef409094"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_Mu , typename T_Sigma , typename T_D , require_all_matrix_t&lt; T_y, T_Mu, T_Sigma, T_D &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga64262a3799093d51c79227c7ef409094"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_Mu, T_Sigma, T_D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga64262a3799093d51c79227c7ef409094">stan::math::matrix_normal_prec_log</a> (const T_y &amp;y, const T_Mu &amp;Mu, const T_Sigma &amp;Sigma, const T_D &amp;D)</td></tr>
<tr class="memdesc:ga64262a3799093d51c79227c7ef409094"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the matrix normal density for the given y, mu, Sigma and D where Sigma and D are given as precision matrices, not covariance matrices.  <a href="../../d1/d04/group__multivar__dists.html#ga64262a3799093d51c79227c7ef409094">More...</a><br /></td></tr>
<tr class="separator:ga64262a3799093d51c79227c7ef409094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7c0d07cf387dd011b3d244907813488"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_Mu , typename T_Sigma , typename T_D , require_all_matrix_t&lt; T_y, T_Mu, T_Sigma, T_D &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab7c0d07cf387dd011b3d244907813488"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_Mu, T_Sigma, T_D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gab7c0d07cf387dd011b3d244907813488">stan::math::matrix_normal_prec_log</a> (const T_y &amp;y, const T_Mu &amp;Mu, const T_Sigma &amp;Sigma, const T_D &amp;D)</td></tr>
<tr class="separator:gab7c0d07cf387dd011b3d244907813488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafacda7490d4f642b087dbf55274bcb9a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_Mu , typename T_Sigma , typename T_D , require_all_matrix_t&lt; T_y, T_Mu, T_Sigma, T_D &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gafacda7490d4f642b087dbf55274bcb9a"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_Mu, T_Sigma, T_D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gafacda7490d4f642b087dbf55274bcb9a">stan::math::matrix_normal_prec_lpdf</a> (const T_y &amp;y, const T_Mu &amp;Mu, const T_Sigma &amp;Sigma, const T_D &amp;D)</td></tr>
<tr class="memdesc:gafacda7490d4f642b087dbf55274bcb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the matrix normal density for the given y, mu, Sigma and D where Sigma and D are given as precision matrices, not covariance matrices.  <a href="../../d1/d04/group__multivar__dists.html#gafacda7490d4f642b087dbf55274bcb9a">More...</a><br /></td></tr>
<tr class="separator:gafacda7490d4f642b087dbf55274bcb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e4ff308feab4aaf90dd7036f85667d2"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ga3e4ff308feab4aaf90dd7036f85667d2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga3e4ff308feab4aaf90dd7036f85667d2">stan::math::matrix_normal_prec_rng</a> (const Eigen::MatrixXd &amp;Mu, const Eigen::MatrixXd &amp;Sigma, const Eigen::MatrixXd &amp;D, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga3e4ff308feab4aaf90dd7036f85667d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample from the the matrix normal distribution for the given Mu, Sigma and D where Sigma and D are given as precision matrices, not covariance matrices.  <a href="../../d1/d04/group__multivar__dists.html#ga3e4ff308feab4aaf90dd7036f85667d2">More...</a><br /></td></tr>
<tr class="separator:ga3e4ff308feab4aaf90dd7036f85667d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92e43d15693f5421f3a8a85b903e8a22"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_covar , typename T_w &gt; </td></tr>
<tr class="memitem:ga92e43d15693f5421f3a8a85b903e8a22"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_covar, T_w &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga92e43d15693f5421f3a8a85b903e8a22">stan::math::multi_gp_cholesky_log</a> (const T_y &amp;y, const T_covar &amp;L, const T_w &amp;w)</td></tr>
<tr class="memdesc:ga92e43d15693f5421f3a8a85b903e8a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a multivariate Gaussian Process for the given y, w, and a Cholesky factor L of the kernel matrix Sigma.  <a href="../../d1/d04/group__multivar__dists.html#ga92e43d15693f5421f3a8a85b903e8a22">More...</a><br /></td></tr>
<tr class="separator:ga92e43d15693f5421f3a8a85b903e8a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80d0035ddc21ae34c30faeee40995456"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_covar , typename T_w &gt; </td></tr>
<tr class="memitem:ga80d0035ddc21ae34c30faeee40995456"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_covar, T_w &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga80d0035ddc21ae34c30faeee40995456">stan::math::multi_gp_cholesky_log</a> (const T_y &amp;y, const T_covar &amp;L, const T_w &amp;w)</td></tr>
<tr class="separator:ga80d0035ddc21ae34c30faeee40995456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac52b7477faba2eb49537ec31d4d5461f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_covar , typename T_w , require_all_eigen_matrix_dynamic_t&lt; T_y, T_covar &gt; *  = nullptr, require_eigen_col_vector_t&lt; T_w &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac52b7477faba2eb49537ec31d4d5461f"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_covar, T_w &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gac52b7477faba2eb49537ec31d4d5461f">stan::math::multi_gp_cholesky_lpdf</a> (const T_y &amp;y, const T_covar &amp;L, const T_w &amp;w)</td></tr>
<tr class="memdesc:gac52b7477faba2eb49537ec31d4d5461f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a multivariate Gaussian Process for the given y, w, and a Cholesky factor L of the kernel matrix Sigma.  <a href="../../d1/d04/group__multivar__dists.html#gac52b7477faba2eb49537ec31d4d5461f">More...</a><br /></td></tr>
<tr class="separator:gac52b7477faba2eb49537ec31d4d5461f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac395a822d38d24a39ef02e695435c7f4"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_covar , typename T_w &gt; </td></tr>
<tr class="memitem:gac395a822d38d24a39ef02e695435c7f4"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_covar, T_w &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gac395a822d38d24a39ef02e695435c7f4">stan::math::multi_gp_log</a> (const T_y &amp;y, const T_covar &amp;Sigma, const T_w &amp;w)</td></tr>
<tr class="memdesc:gac395a822d38d24a39ef02e695435c7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a multivariate Gaussian Process for the given y, Sigma, and w.  <a href="../../d1/d04/group__multivar__dists.html#gac395a822d38d24a39ef02e695435c7f4">More...</a><br /></td></tr>
<tr class="separator:gac395a822d38d24a39ef02e695435c7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa0a8ceba99d5354ab0fa1fc385b44e9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_covar , typename T_w &gt; </td></tr>
<tr class="memitem:gaaa0a8ceba99d5354ab0fa1fc385b44e9"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_covar, T_w &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gaaa0a8ceba99d5354ab0fa1fc385b44e9">stan::math::multi_gp_log</a> (const T_y &amp;y, const T_covar &amp;Sigma, const T_w &amp;w)</td></tr>
<tr class="separator:gaaa0a8ceba99d5354ab0fa1fc385b44e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d9a55dfe7ed454e7972010da608c530"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_covar , typename T_w , require_all_matrix_t&lt; T_y, T_covar &gt; *  = nullptr, require_col_vector_t&lt; T_w &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0d9a55dfe7ed454e7972010da608c530"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_covar, T_w &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga0d9a55dfe7ed454e7972010da608c530">stan::math::multi_gp_lpdf</a> (const T_y &amp;y, const T_covar &amp;Sigma, const T_w &amp;w)</td></tr>
<tr class="memdesc:ga0d9a55dfe7ed454e7972010da608c530"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a multivariate Gaussian Process for the given y, Sigma, and w.  <a href="../../d1/d04/group__multivar__dists.html#ga0d9a55dfe7ed454e7972010da608c530">More...</a><br /></td></tr>
<tr class="separator:ga0d9a55dfe7ed454e7972010da608c530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace251fa4176a6620b0cc601eea04c0c5"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:gace251fa4176a6620b0cc601eea04c0c5"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gace251fa4176a6620b0cc601eea04c0c5">stan::math::multi_normal_cholesky_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;L)</td></tr>
<tr class="memdesc:gace251fa4176a6620b0cc601eea04c0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the multivariate normal density for the given y, mu, and a Cholesky factor L of the variance matrix.  <a href="../../d1/d04/group__multivar__dists.html#gace251fa4176a6620b0cc601eea04c0c5">More...</a><br /></td></tr>
<tr class="separator:gace251fa4176a6620b0cc601eea04c0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ee11ca85a43b351e4d8975a665f6328"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:ga6ee11ca85a43b351e4d8975a665f6328"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga6ee11ca85a43b351e4d8975a665f6328">stan::math::multi_normal_cholesky_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;L)</td></tr>
<tr class="separator:ga6ee11ca85a43b351e4d8975a665f6328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e547a39d62c5161c0908d94cd53c992"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_covar , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_covar &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e547a39d62c5161c0908d94cd53c992"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga5e547a39d62c5161c0908d94cd53c992">stan::math::multi_normal_cholesky_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;L)</td></tr>
<tr class="memdesc:ga5e547a39d62c5161c0908d94cd53c992"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the multivariate normal density for the given y, mu, and a Cholesky factor L of the variance matrix.  <a href="../../d1/d04/group__multivar__dists.html#ga5e547a39d62c5161c0908d94cd53c992">More...</a><br /></td></tr>
<tr class="separator:ga5e547a39d62c5161c0908d94cd53c992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8768d74289b60b1a89cfc60050e137d9"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , class RNG &gt; </td></tr>
<tr class="memitem:ga8768d74289b60b1a89cfc60050e137d9"><td class="memTemplItemLeft" align="right" valign="top">StdVectorBuilder&lt; true, Eigen::VectorXd, T_loc &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga8768d74289b60b1a89cfc60050e137d9">stan::math::multi_normal_cholesky_rng</a> (const T_loc &amp;mu, const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;L, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga8768d74289b60b1a89cfc60050e137d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a multivariate normal random variate with the given location and Cholesky factorization of the covariance using the specified random number generator.  <a href="../../d1/d04/group__multivar__dists.html#ga8768d74289b60b1a89cfc60050e137d9">More...</a><br /></td></tr>
<tr class="separator:ga8768d74289b60b1a89cfc60050e137d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea7c9f516fd2163ec5021d2731b6a18a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:gaea7c9f516fd2163ec5021d2731b6a18a"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gaea7c9f516fd2163ec5021d2731b6a18a">stan::math::multi_normal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:gaea7c9f516fd2163ec5021d2731b6a18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46e1d2d523388bc94abb1d7925c10643"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:ga46e1d2d523388bc94abb1d7925c10643"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga46e1d2d523388bc94abb1d7925c10643">stan::math::multi_normal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:ga46e1d2d523388bc94abb1d7925c10643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae01340614eb63292b100327af71f2626"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:gae01340614eb63292b100327af71f2626"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gae01340614eb63292b100327af71f2626">stan::math::multi_normal_prec_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:gae01340614eb63292b100327af71f2626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8a791079717a70af1ceb21d240c85df"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:gad8a791079717a70af1ceb21d240c85df"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gad8a791079717a70af1ceb21d240c85df">stan::math::multi_normal_prec_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:gad8a791079717a70af1ceb21d240c85df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc2a15a609c6e3967046385e6c411041"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , class RNG &gt; </td></tr>
<tr class="memitem:gadc2a15a609c6e3967046385e6c411041"><td class="memTemplItemLeft" align="right" valign="top">StdVectorBuilder&lt; true, Eigen::VectorXd, T_loc &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gadc2a15a609c6e3967046385e6c411041">stan::math::multi_normal_prec_rng</a> (const T_loc &amp;mu, const Eigen::MatrixXd &amp;S, RNG &amp;rng)</td></tr>
<tr class="memdesc:gadc2a15a609c6e3967046385e6c411041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a multivariate normal random variate with the given location and precision using the specified random number generator.  <a href="../../d1/d04/group__multivar__dists.html#gadc2a15a609c6e3967046385e6c411041">More...</a><br /></td></tr>
<tr class="separator:gadc2a15a609c6e3967046385e6c411041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d5464fa79ab08a7731cef29ded7e384"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , class RNG &gt; </td></tr>
<tr class="memitem:ga8d5464fa79ab08a7731cef29ded7e384"><td class="memTemplItemLeft" align="right" valign="top">StdVectorBuilder&lt; true, Eigen::VectorXd, T_loc &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga8d5464fa79ab08a7731cef29ded7e384">stan::math::multi_normal_rng</a> (const T_loc &amp;mu, const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;S, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga8d5464fa79ab08a7731cef29ded7e384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a multivariate normal random variate with the given location and covariance using the specified random number generator.  <a href="../../d1/d04/group__multivar__dists.html#ga8d5464fa79ab08a7731cef29ded7e384">More...</a><br /></td></tr>
<tr class="separator:ga8d5464fa79ab08a7731cef29ded7e384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ad01e45f4c8eabe5c813e0cc4eece98"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga5ad01e45f4c8eabe5c813e0cc4eece98"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga5ad01e45f4c8eabe5c813e0cc4eece98">stan::math::multi_student_t_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;Sigma)</td></tr>
<tr class="memdesc:ga5ad01e45f4c8eabe5c813e0cc4eece98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the multivariate Student t distribution at the specified arguments.  <a href="../../d1/d04/group__multivar__dists.html#ga5ad01e45f4c8eabe5c813e0cc4eece98">More...</a><br /></td></tr>
<tr class="separator:ga5ad01e45f4c8eabe5c813e0cc4eece98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21dabf2487a3e696c03c2faada3a6e92"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga21dabf2487a3e696c03c2faada3a6e92"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga21dabf2487a3e696c03c2faada3a6e92">stan::math::multi_student_t_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;Sigma)</td></tr>
<tr class="separator:ga21dabf2487a3e696c03c2faada3a6e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95c2aa50c01a2eb18d3ec107fb58fabc"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga95c2aa50c01a2eb18d3ec107fb58fabc"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga95c2aa50c01a2eb18d3ec107fb58fabc">stan::math::multi_student_t_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;Sigma)</td></tr>
<tr class="memdesc:ga95c2aa50c01a2eb18d3ec107fb58fabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the multivariate Student t distribution at the specified arguments.  <a href="../../d1/d04/group__multivar__dists.html#ga95c2aa50c01a2eb18d3ec107fb58fabc">More...</a><br /></td></tr>
<tr class="separator:ga95c2aa50c01a2eb18d3ec107fb58fabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga098f5cc8afde056925944720d5295fd2"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , class RNG &gt; </td></tr>
<tr class="memitem:ga098f5cc8afde056925944720d5295fd2"><td class="memTemplItemLeft" align="right" valign="top">StdVectorBuilder&lt; true, Eigen::VectorXd, T_loc &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga098f5cc8afde056925944720d5295fd2">stan::math::multi_student_t_rng</a> (double nu, const T_loc &amp;mu, const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;S, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga098f5cc8afde056925944720d5295fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a multivariate student-t random variate with the given degrees of freedom location and covariance using the specified random number generator.  <a href="../../d1/d04/group__multivar__dists.html#ga098f5cc8afde056925944720d5295fd2">More...</a><br /></td></tr>
<tr class="separator:ga098f5cc8afde056925944720d5295fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec16418a01064477e58f33a044043016"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob &gt; </td></tr>
<tr class="memitem:gaec16418a01064477e58f33a044043016"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gaec16418a01064477e58f33a044043016">stan::math::multinomial_log</a> (const std::vector&lt; int &gt; &amp;ns, const T_prob &amp;theta)</td></tr>
<tr class="separator:gaec16418a01064477e58f33a044043016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab017f8f0887aa6c9a2ca92e5a4a2a1ee"><td class="memTemplParams" colspan="2">template&lt;typename T_prob &gt; </td></tr>
<tr class="memitem:gab017f8f0887aa6c9a2ca92e5a4a2a1ee"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gab017f8f0887aa6c9a2ca92e5a4a2a1ee">stan::math::multinomial_log</a> (const std::vector&lt; int &gt; &amp;ns, const T_prob &amp;theta)</td></tr>
<tr class="separator:gab017f8f0887aa6c9a2ca92e5a4a2a1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbefda25fc43e26d3a5d2818bb086dd3"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_beta , require_eigen_col_vector_t&lt; T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gafbefda25fc43e26d3a5d2818bb086dd3"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gafbefda25fc43e26d3a5d2818bb086dd3">stan::math::multinomial_logit_log</a> (const std::vector&lt; int &gt; &amp;ns, const T_beta &amp;beta)</td></tr>
<tr class="separator:gafbefda25fc43e26d3a5d2818bb086dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb6cb28e7a16a526f9467941e6cf88e"><td class="memTemplParams" colspan="2">template&lt;typename T_beta , require_eigen_col_vector_t&lt; T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4fb6cb28e7a16a526f9467941e6cf88e"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga4fb6cb28e7a16a526f9467941e6cf88e">stan::math::multinomial_logit_log</a> (const std::vector&lt; int &gt; &amp;ns, const T_beta &amp;beta)</td></tr>
<tr class="separator:ga4fb6cb28e7a16a526f9467941e6cf88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabe7d1ac7913e83814c3294d996e91c9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_beta , typename T_prob  = scalar_type_t&lt;T_beta&gt;, require_eigen_col_vector_t&lt; T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaabe7d1ac7913e83814c3294d996e91c9"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gaabe7d1ac7913e83814c3294d996e91c9">stan::math::multinomial_logit_lpmf</a> (const std::vector&lt; int &gt; &amp;ns, const T_beta &amp;beta)</td></tr>
<tr class="memdesc:gaabe7d1ac7913e83814c3294d996e91c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multinomial log PMF in log parametrization.  <a href="../../d1/d04/group__multivar__dists.html#gaabe7d1ac7913e83814c3294d996e91c9">More...</a><br /></td></tr>
<tr class="separator:gaabe7d1ac7913e83814c3294d996e91c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04d59be2c49c48a314b727ee2e3831cf"><td class="memTemplParams" colspan="2">template&lt;class RNG , typename T_beta , require_eigen_col_vector_t&lt; T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga04d59be2c49c48a314b727ee2e3831cf"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga04d59be2c49c48a314b727ee2e3831cf">stan::math::multinomial_logit_rng</a> (const T_beta &amp;beta, int N, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga04d59be2c49c48a314b727ee2e3831cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a draw from a Multinomial distribution given a a vector of unnormalized log probabilities and a pseudo-random number generator.  <a href="../../d1/d04/group__multivar__dists.html#ga04d59be2c49c48a314b727ee2e3831cf">More...</a><br /></td></tr>
<tr class="separator:ga04d59be2c49c48a314b727ee2e3831cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec367ab511061785e827db08b413fee"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_precision &gt; </td></tr>
<tr class="memitem:ga9ec367ab511061785e827db08b413fee"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_x, T_alpha, T_beta, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga9ec367ab511061785e827db08b413fee">stan::math::neg_binomial_2_log_glm_log</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;beta, const T_precision &amp;phi)</td></tr>
<tr class="separator:ga9ec367ab511061785e827db08b413fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28bbe881fe2967522f7ea474c7f3cab1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_precision &gt; </td></tr>
<tr class="memitem:ga28bbe881fe2967522f7ea474c7f3cab1"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_x, T_alpha, T_beta, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga28bbe881fe2967522f7ea474c7f3cab1">stan::math::neg_binomial_2_log_glm_log</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;beta, const T_precision &amp;phi)</td></tr>
<tr class="separator:ga28bbe881fe2967522f7ea474c7f3cab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5c3fd7ac58ea81db866febba20fec6d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_precision , require_eigen_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab5c3fd7ac58ea81db866febba20fec6d"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_x, T_alpha, T_beta, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gab5c3fd7ac58ea81db866febba20fec6d">stan::math::neg_binomial_2_log_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;beta, const T_precision &amp;phi)</td></tr>
<tr class="memdesc:gab5c3fd7ac58ea81db866febba20fec6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Negative-Binomial-2 distribution and log link function.  <a href="../../d1/d04/group__multivar__dists.html#gab5c3fd7ac58ea81db866febba20fec6d">More...</a><br /></td></tr>
<tr class="separator:gab5c3fd7ac58ea81db866febba20fec6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4473e11ac43137c4e42f785b610f070b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_scale &gt; </td></tr>
<tr class="memitem:ga4473e11ac43137c4e42f785b610f070b"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_x, T_alpha, T_beta, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga4473e11ac43137c4e42f785b610f070b">stan::math::normal_id_glm_log</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;beta, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga4473e11ac43137c4e42f785b610f070b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57b3d600f49fc423fa936b7fa3c9e379"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_scale &gt; </td></tr>
<tr class="memitem:ga57b3d600f49fc423fa936b7fa3c9e379"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_x, T_alpha, T_beta, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga57b3d600f49fc423fa936b7fa3c9e379">stan::math::normal_id_glm_log</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;beta, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga57b3d600f49fc423fa936b7fa3c9e379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5abfa04756222a7b66c2567d12182aea"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_scale , require_eigen_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5abfa04756222a7b66c2567d12182aea"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_x, T_alpha, T_beta, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga5abfa04756222a7b66c2567d12182aea">stan::math::normal_id_glm_lpdf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;beta, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:ga5abfa04756222a7b66c2567d12182aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PDF of the Generalized Linear Model (GLM) with Normal distribution and id link function.  <a href="../../d1/d04/group__multivar__dists.html#ga5abfa04756222a7b66c2567d12182aea">More...</a><br /></td></tr>
<tr class="separator:ga5abfa04756222a7b66c2567d12182aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9b0f885af3060f53d14e9e113729fc"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_beta , typename T_cuts , require_eigen_t&lt; T_x &gt; *  = nullptr, require_all_eigen_col_vector_t&lt; T_beta, T_cuts &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gace9b0f885af3060f53d14e9e113729fc"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_x, T_beta, T_cuts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gace9b0f885af3060f53d14e9e113729fc">stan::math::ordered_logistic_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_beta &amp;beta, const T_cuts &amp;cuts)</td></tr>
<tr class="memdesc:gace9b0f885af3060f53d14e9e113729fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the ordinal regression Generalized Linear Model (GLM).  <a href="../../d1/d04/group__multivar__dists.html#gace9b0f885af3060f53d14e9e113729fc">More...</a><br /></td></tr>
<tr class="separator:gace9b0f885af3060f53d14e9e113729fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23b3433b23d80fd5d7289e4922a21060"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_cut &gt; </td></tr>
<tr class="memitem:ga23b3433b23d80fd5d7289e4922a21060"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_loc, T_cut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga23b3433b23d80fd5d7289e4922a21060">stan::math::ordered_logistic_log</a> (const T_y &amp;y, const T_loc &amp;lambda, const T_cut &amp;c)</td></tr>
<tr class="memdesc:ga23b3433b23d80fd5d7289e4922a21060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (natural) log probability of the integer/s given the vector of continuous location/s and specified cutpoints in an ordered logistic model.  <a href="../../d1/d04/group__multivar__dists.html#ga23b3433b23d80fd5d7289e4922a21060">More...</a><br /></td></tr>
<tr class="separator:ga23b3433b23d80fd5d7289e4922a21060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3d5dfc0ac36a7701b5fb2b616850837"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_cut &gt; </td></tr>
<tr class="memitem:gae3d5dfc0ac36a7701b5fb2b616850837"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_loc, T_cut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gae3d5dfc0ac36a7701b5fb2b616850837">stan::math::ordered_logistic_log</a> (const T_y &amp;y, const T_loc &amp;lambda, const T_cut &amp;c)</td></tr>
<tr class="separator:gae3d5dfc0ac36a7701b5fb2b616850837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b2bd081aa551947d0b5c96d3928d92"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_cut , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_cut &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab0b2bd081aa551947d0b5c96d3928d92"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_loc, T_cut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gab0b2bd081aa551947d0b5c96d3928d92">stan::math::ordered_logistic_lpmf</a> (const T_y &amp;y, const T_loc &amp;lambda, const T_cut &amp;c)</td></tr>
<tr class="memdesc:gab0b2bd081aa551947d0b5c96d3928d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (natural) log probability of the specified array of integers given the vector of continuous locations and specified cutpoints in an ordered logistic model.  <a href="../../d1/d04/group__multivar__dists.html#gab0b2bd081aa551947d0b5c96d3928d92">More...</a><br /></td></tr>
<tr class="separator:gab0b2bd081aa551947d0b5c96d3928d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56dd2feeb184d8ec2b6b62eabfe237f8"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_cut &gt; </td></tr>
<tr class="memitem:ga56dd2feeb184d8ec2b6b62eabfe237f8"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_loc, T_cut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga56dd2feeb184d8ec2b6b62eabfe237f8">stan::math::ordered_probit_log</a> (const T_y &amp;y, const T_loc &amp;lambda, const T_cut &amp;c)</td></tr>
<tr class="memdesc:ga56dd2feeb184d8ec2b6b62eabfe237f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (natural) log probability of the integer/s given the vector of continuous location/s and specified cutpoints in an ordered probit model.  <a href="../../d1/d04/group__multivar__dists.html#ga56dd2feeb184d8ec2b6b62eabfe237f8">More...</a><br /></td></tr>
<tr class="separator:ga56dd2feeb184d8ec2b6b62eabfe237f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf76d0e635a7190c1a13da2b3ddbd468"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_cut &gt; </td></tr>
<tr class="memitem:gadf76d0e635a7190c1a13da2b3ddbd468"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_loc, T_cut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gadf76d0e635a7190c1a13da2b3ddbd468">stan::math::ordered_probit_log</a> (const T_y &amp;y, const T_loc &amp;lambda, const T_cut &amp;c)</td></tr>
<tr class="separator:gadf76d0e635a7190c1a13da2b3ddbd468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44b1065be3677f5745ae216896cf59ca"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_cut &gt; </td></tr>
<tr class="memitem:ga44b1065be3677f5745ae216896cf59ca"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_loc, T_cut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga44b1065be3677f5745ae216896cf59ca">stan::math::ordered_probit_lpmf</a> (const T_y &amp;y, const T_loc &amp;lambda, const T_cut &amp;c)</td></tr>
<tr class="memdesc:ga44b1065be3677f5745ae216896cf59ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (natural) log probability of the specified array of integers given the vector of continuous locations and array of specified cutpoints in an ordered probit model.  <a href="../../d1/d04/group__multivar__dists.html#ga44b1065be3677f5745ae216896cf59ca">More...</a><br /></td></tr>
<tr class="separator:ga44b1065be3677f5745ae216896cf59ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ec719b8f6c82108959c6c8668ef4027"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:ga4ec719b8f6c82108959c6c8668ef4027"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga4ec719b8f6c82108959c6c8668ef4027">stan::math::poisson_log_glm_log</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;beta)</td></tr>
<tr class="separator:ga4ec719b8f6c82108959c6c8668ef4027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c49cb4ea519606e1432989b0ddaef9b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:ga9c49cb4ea519606e1432989b0ddaef9b"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga9c49cb4ea519606e1432989b0ddaef9b">stan::math::poisson_log_glm_log</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;beta)</td></tr>
<tr class="separator:ga9c49cb4ea519606e1432989b0ddaef9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdac9b18cd635354f25b6a4208b4ccbc"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , require_eigen_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabdac9b18cd635354f25b6a4208b4ccbc"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gabdac9b18cd635354f25b6a4208b4ccbc">stan::math::poisson_log_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;beta)</td></tr>
<tr class="memdesc:gabdac9b18cd635354f25b6a4208b4ccbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Poisson distribution and log link function.  <a href="../../d1/d04/group__multivar__dists.html#gabdac9b18cd635354f25b6a4208b4ccbc">More...</a><br /></td></tr>
<tr class="separator:gabdac9b18cd635354f25b6a4208b4ccbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87c0dd922ca1264e0a9edf696b1c1df5"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:ga87c0dd922ca1264e0a9edf696b1c1df5"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#ga87c0dd922ca1264e0a9edf696b1c1df5">stan::math::wishart_log</a> (const T_y &amp;W, const T_dof &amp;nu, const T_scale &amp;S)</td></tr>
<tr class="memdesc:ga87c0dd922ca1264e0a9edf696b1c1df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Wishart density for the given W, degrees of freedom, and scale matrix.  <a href="../../d1/d04/group__multivar__dists.html#ga87c0dd922ca1264e0a9edf696b1c1df5">More...</a><br /></td></tr>
<tr class="separator:ga87c0dd922ca1264e0a9edf696b1c1df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb976f445cd5d31069393ee76d763d14"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:gabb976f445cd5d31069393ee76d763d14"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gabb976f445cd5d31069393ee76d763d14">stan::math::wishart_log</a> (const T_y &amp;W, const T_dof &amp;nu, const T_scale &amp;S)</td></tr>
<tr class="separator:gabb976f445cd5d31069393ee76d763d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2ed3c31ff75e645d1b12662685a9492"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale , require_stan_scalar_t&lt; T_dof &gt; *  = nullptr, require_all_matrix_t&lt; T_y, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gad2ed3c31ff75e645d1b12662685a9492"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d04/group__multivar__dists.html#gad2ed3c31ff75e645d1b12662685a9492">stan::math::wishart_lpdf</a> (const T_y &amp;W, const T_dof &amp;nu, const T_scale &amp;S)</td></tr>
<tr class="memdesc:gad2ed3c31ff75e645d1b12662685a9492"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Wishart density for the given W, degrees of freedom, and scale matrix.  <a href="../../d1/d04/group__multivar__dists.html#gad2ed3c31ff75e645d1b12662685a9492">More...</a><br /></td></tr>
<tr class="separator:gad2ed3c31ff75e645d1b12662685a9492"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga25d3a0c1398ed337c7979559b1156727"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_x, T_alpha, T_beta&gt; stan::math::bernoulli_logit_glm_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>use <code>bernoulli_logit_glm_lpmf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d4/d33/bernoulli__logit__glm__log_8hpp_source.html#l00015">15</a> of file <a class="el" href="../../d4/d33/bernoulli__logit__glm__log_8hpp_source.html">bernoulli_logit_glm_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaa134b4fd02e5d004766d37732e7801b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_x, T_alpha, T_beta&gt; stan::math::bernoulli_logit_glm_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>use <code>bernoulli_logit_glm_lpmf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d4/d33/bernoulli__logit__glm__log_8hpp_source.html#l00025">25</a> of file <a class="el" href="../../d4/d33/bernoulli__logit__glm__log_8hpp_source.html">bernoulli_logit_glm_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae708042f23d9a65b9b9d62c41b9c5e8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , require_eigen_t&lt; T_x &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_x, T_alpha, T_beta&gt; stan::math::bernoulli_logit_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the Generalized Linear Model (GLM) with Bernoulli distribution and logit link function. </p>
<p>The idea is that bernoulli_logit_glm_lpmf(y, x, alpha, beta) should compute a more efficient version of bernoulli_logit_lpmf(y, alpha + x * beta) by using analytically simplified gradients. If containers are supplied, returns the log sum of the probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>type of binary vector of dependent variables (labels); this can also be a single binary value; </td></tr>
    <tr><td class="paramname">T_x</td><td>type of the matrix of independent variables (features) </td></tr>
    <tr><td class="paramname">T_alpha</td><td>type of the intercept(s); this can be a vector (of the same length as y) of intercepts or a single value (for models with constant intercept); </td></tr>
    <tr><td class="paramname">T_beta</td><td>type of the weight vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>binary scalar or vector parameter. If it is a scalar it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">x</td><td>design matrix or row vector. If it is a row vector it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if x, beta or alpha is infinite. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not binary. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d2/d4c/prim_2prob_2bernoulli__logit__glm__lpmf_8hpp_source.html#l00050">50</a> of file <a class="el" href="../../d2/d4c/prim_2prob_2bernoulli__logit__glm__lpmf_8hpp_source.html">bernoulli_logit_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga305e57f094bad826b293179514f1c7b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_x , typename T_alpha , typename T_beta , class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorBuilder&lt;true, int, T_alpha&gt;::type stan::math::bernoulli_logit_glm_rng </td>
          <td>(</td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a draw from the Generalized Linear Model (GLM) with Bernoulli distribution and logit link function. </p>
<p>This is a convenience wrapper around <code>bernoulli_logit_rng(alpha + x * beta, rng)</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_x</td><td>type of the matrix of independent variables (features); this should be an Eigen::Matrix whose number of columns should match the length of beta; the number of rows is the number of samples. </td></tr>
    <tr><td class="paramname">T_alpha</td><td>type of the intercept(s); this can be a vector of the same length as y) of intercepts or a single value (for models with constant intercept); if a vector its length should match x's row-count; </td></tr>
    <tr><td class="paramname">T_beta</td><td>type of the weight vector; </td></tr>
    <tr><td class="paramname">RNG</td><td>Type of pseudo-random number generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>design matrix </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
    <tr><td class="paramname">rng</td><td>Pseudo-random number generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bernoulli logit glm random variate </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if x, beta or alpha is infinite. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d8/d91/bernoulli__logit__glm__rng_8hpp_source.html#l00043">43</a> of file <a class="el" href="../../d8/d91/bernoulli__logit__glm__rng_8hpp_source.html">bernoulli_logit_glm_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga59609a885c7799e09536dfaac422408d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n , typename T_prob &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_prob&gt; stan::math::categorical_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>use <code>categorical_lpmf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../de/d95/categorical__log_8hpp_source.html#l00016">16</a> of file <a class="el" href="../../de/d95/categorical__log_8hpp_source.html">categorical_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4f9fccab8df853934c6e093ed07562d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_prob &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_prob&gt; stan::math::categorical_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000037">Deprecated:</a></b></dt><dd>use <code>categorical_lpmf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../de/d95/categorical__log_8hpp_source.html#l00025">25</a> of file <a class="el" href="../../de/d95/categorical__log_8hpp_source.html">categorical_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga17b9cdb8336f173a13db846c509e5412"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , require_eigen_t&lt; T_x &gt; *  = nullptr, require_eigen_col_vector_t&lt; T_alpha &gt; *  = nullptr, require_eigen_matrix_dynamic_t&lt; T_beta &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_x, T_alpha, T_beta&gt; stan::math::categorical_logit_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the Generalized Linear Model (GLM) with categorical distribution and logit (softmax) link function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>type of classes. It can be either <code>std::vector&lt;int&gt;</code> or <code>int</code>. </td></tr>
    <tr><td class="paramname">T_x_scalar</td><td>type of the matrix of independent variables (features) </td></tr>
    <tr><td class="paramname">T_alpha</td><td>type of the intercept vector </td></tr>
    <tr><td class="paramname">T_beta</td><td>type of the matrix of weights </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>a scalar or vector of classes. If it is a scalar it will be broadcast - used for all instances. Values should be between 1 and number of classes, including endpoints. </td></tr>
    <tr><td class="paramname">x</td><td>design matrix or row vector. If it is a row vector it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept vector (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>x, beta or alpha is infinite or y is not within bounds </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../df/d55/prim_2prob_2categorical__logit__glm__lpmf_8hpp_source.html#l00046">46</a> of file <a class="el" href="../../df/d55/prim_2prob_2categorical__logit__glm__lpmf_8hpp_source.html">categorical_logit_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaa9baba3b60a4d1e78c1ab36d797d36cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n , typename T_prob &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_prob&gt; stan::math::categorical_logit_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>use <code>categorical_logit_lpmf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d7/d5f/categorical__logit__log_8hpp_source.html#l00016">16</a> of file <a class="el" href="../../d7/d5f/categorical__logit__log_8hpp_source.html">categorical_logit_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga801751852f64866699bcf2242813c026"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_prob &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_prob&gt; stan::math::categorical_logit_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd>use <code>categorical_logit_lpmf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d7/d5f/categorical__logit__log_8hpp_source.html#l00025">25</a> of file <a class="el" href="../../d7/d5f/categorical__logit__log_8hpp_source.html">categorical_logit_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga735693bdf47c855697175ca6f5698929"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::categorical_logit_rng </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a draw from a Categorical distribution given a a vector of unnormalized log probabilities and a psuedo-random number generator. </p>
<p>This is a convenience wrapper around <code>categorical_rng(softmax(beta), rng)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RNG</td><td>Type of pseudo-random number generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beta</td><td>Vector of unnormalized log probabilities. </td></tr>
    <tr><td class="paramname">rng</td><td>Pseudo-random number generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Categorical random variate </dd></dl>

<p>Definition at line <a class="el" href="../../db/d26/categorical__logit__rng_8hpp_source.html#l00029">29</a> of file <a class="el" href="../../db/d26/categorical__logit__rng_8hpp_source.html">categorical_logit_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae3d5bb184fcb8329ec0b157ef7845321"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_prob , typename T_prior_size &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_prob, T_prior_size&gt; stan::math::dirichlet_log </td>
          <td>(</td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prior_size &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the Dirichlet density for the given theta and a vector of prior sample sizes, alpha. </p>
<p>Each element of alpha must be greater than 0. Each element of theta must be greater than or 0. Theta sums to 1.</p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000048">Deprecated:</a></b></dt><dd>use <code>dirichlet_lpdf</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>A scalar vector. </td></tr>
    <tr><td class="paramname">alpha</td><td>Prior sample sizes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the Dirichlet density. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if any element of alpha is less than or equal to 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if any element of theta is less than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if the sum of theta is not 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_prob</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_prior_size</td><td>Type of prior sample sizes. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d4/d59/dirichlet__log_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../d4/d59/dirichlet__log_8hpp_source.html">dirichlet_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga1aa63ffb06e9e808dda50ee7494e25b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_prob , typename T_prior_size &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_prob, T_prior_size&gt; stan::math::dirichlet_log </td>
          <td>(</td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prior_size &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000049">Deprecated:</a></b></dt><dd>use <code>dirichlet_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d4/d59/dirichlet__log_8hpp_source.html#l00040">40</a> of file <a class="el" href="../../d4/d59/dirichlet__log_8hpp_source.html">dirichlet_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga993200aac080067864439bb59dc12bd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_prob , typename T_prior_size , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_prob, T_prior_size &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_prob, T_prior_size&gt; stan::math::dirichlet_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prior_size &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the Dirichlet density for the given theta and a vector of prior sample sizes, alpha. </p>
<p>Each element of alpha must be greater than 0. Each element of theta must be greater than or 0. Theta sums to 1.</p>
<p class="formulaDsp">
\[ \theta\sim\mbox{Dirichlet}(\alpha_1,\ldots,\alpha_k)\\ \log(p(\theta\,|\,\alpha_1,\ldots,\alpha_k))=\log\left( \frac{\Gamma(\alpha_1+\cdots+\alpha_k)}{\Gamma(\alpha_1)+ \cdots+\Gamma(\alpha_k)}* \left(\theta_1^{\alpha_1-1}+ \cdots+\theta_k^{\alpha_k-1}\right)\right)\\ =\log(\Gamma(\alpha_1+\cdots+\alpha_k))-\left( \log(\Gamma(\alpha_1))+\cdots+\log(\Gamma(\alpha_k))\right)+ (\alpha_1-1)\log(\theta_1)+\cdots+(\alpha_k-1)\log(\theta_k) \]
</p>
<p class="formulaDsp">
\[ \frac{\partial }{\partial \theta_x}\log(p(\theta\,|\,\alpha_1,\ldots,\alpha_k))= \frac{\alpha_x-1}{\theta_x} \]
</p>
<p class="formulaDsp">
\[ \frac{\partial}{\partial\alpha_x}\log(p(\theta\,|\,\alpha_1,\ldots,\alpha_k)) =\psi_{(0)}(\sum\alpha)-\psi_{(0)}(\alpha_x)+\log\theta_x \]
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_prob</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_prior_size</td><td>type of prior sample sizes </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>A scalar vector. </td></tr>
    <tr><td class="paramname">alpha</td><td>Prior sample sizes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the Dirichlet density. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if any element of alpha is less than or equal to 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if any element of theta is less than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if the sum of theta is not 1. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d4/db7/prim_2prob_2dirichlet__lpdf_8hpp_source.html#l00059">59</a> of file <a class="el" href="../../d4/db7/prim_2prob_2dirichlet__lpdf_8hpp_source.html">dirichlet_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga56d91749cc27fb49662ff50e1112ef9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_prob , typename T_prior_size &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_prob, T_prior_size&gt; stan::math::dirichlet_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prior_size &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000050">Deprecated:</a></b></dt><dd>use <code>dirichlet_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../dd/db3/dirichlet__lpmf_8hpp_source.html#l00014">14</a> of file <a class="el" href="../../dd/db3/dirichlet__lpmf_8hpp_source.html">dirichlet_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gacb288324f889b7da57f2960570f459ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd stan::math::dirichlet_rng </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a draw from a Dirichlet distribution with specified parameters and pseudo-random number generator. </p>
<p>For prior counts greater than zero, the usual algorithm that draws gamma variates and normalizes is used.</p>
<p>For prior counts less than zero (i.e., parameters with value less than one), a log-scale version of the following algorithm is used to deal with underflow:</p>
<blockquote class="doxtable">
<p>G. Marsaglia and W. Tsang. A simple method for generating gamma variables. ACM Transactions on Mathematical Software. 26(3):363&ndash;372, 2000. </p>
</blockquote>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RNG</td><td>type of pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Prior count (plus 1) parameter for Dirichlet. </td></tr>
    <tr><td class="paramname">rng</td><td>Pseudo-random number generator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dc/d3e/dirichlet__rng_8hpp_source.html#l00039">39</a> of file <a class="el" href="../../dc/d3e/dirichlet__rng_8hpp_source.html">dirichlet_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga86f952dd3635d180de80428f9350a35b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_F, T_G, T_V, T_W, T_m0, T_C0&gt; stan::math::gaussian_dlm_obs_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_F &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_G &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_V &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_W &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_m0 &amp;&#160;</td>
          <td class="paramname"><em>m0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_C0 &amp;&#160;</td>
          <td class="paramname"><em>C0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000075">Deprecated:</a></b></dt><dd>use <code>gaussian_dlm_obs_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../dd/ddd/gaussian__dlm__obs__log_8hpp_source.html#l00015">15</a> of file <a class="el" href="../../dd/ddd/gaussian__dlm__obs__log_8hpp_source.html">gaussian_dlm_obs_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9b1ca42a98c13529b45c3ca2af0b75c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_F, T_G, T_V, T_W, T_m0, T_C0&gt; stan::math::gaussian_dlm_obs_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_F &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_G &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_V &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_W &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_m0 &amp;&#160;</td>
          <td class="paramname"><em>m0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_C0 &amp;&#160;</td>
          <td class="paramname"><em>C0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000076">Deprecated:</a></b></dt><dd>use <code>gaussian_dlm_obs_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../dd/ddd/gaussian__dlm__obs__log_8hpp_source.html#l00026">26</a> of file <a class="el" href="../../dd/ddd/gaussian__dlm__obs__log_8hpp_source.html">gaussian_dlm_obs_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaa04df98134e973d4d3ce2e6ba814b18a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 , require_all_eigen_matrix_dynamic_t&lt; T_y, T_F, T_G, T_V, T_W, T_C0 &gt; *  = nullptr, require_eigen_col_vector_t&lt; T_m0 &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt; T_y, T_F, T_G, T_V, T_W, T_m0, T_C0 &gt; stan::math::gaussian_dlm_obs_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_F &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_G &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_V &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_W &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_m0 &amp;&#160;</td>
          <td class="paramname"><em>m0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_C0 &amp;&#160;</td>
          <td class="paramname"><em>C0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The log of a Gaussian dynamic linear model (GDLM). </p>
<p>The log of a Gaussian dynamic linear model (GDLM) with uncorrelated observation disturbances.</p>
<p>This distribution is equivalent to, for \(t = 1:T\), </p><p class="formulaDsp">
\begin{eqnarray*} y_t &amp; \sim N(F&#39; \theta_t, V) \\ \theta_t &amp; \sim N(G \theta_{t-1}, W) \\ \theta_0 &amp; \sim N(m_0, C_0) \end{eqnarray*}
</p>
<p>If V is a vector, then the Kalman filter is applied sequentially.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_F</td><td>type of design matrix </td></tr>
    <tr><td class="paramname">T_G</td><td>type of transition matrix </td></tr>
    <tr><td class="paramname">T_V</td><td>type of observation covariance matrix </td></tr>
    <tr><td class="paramname">T_W</td><td>type of state covariance matrix </td></tr>
    <tr><td class="paramname">T_m0</td><td>type of initial state mean vector </td></tr>
    <tr><td class="paramname">T_C0</td><td>type of initial state covariance matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A r x T matrix of observations. Rows are variables, columns are observations. </td></tr>
    <tr><td class="paramname">F</td><td>A n x r matrix. The design matrix. </td></tr>
    <tr><td class="paramname">G</td><td>A n x n matrix. The transition matrix. </td></tr>
    <tr><td class="paramname">V</td><td>A r x r matrix. The observation covariance matrix. </td></tr>
    <tr><td class="paramname">W</td><td>A n x n matrix. The state covariance matrix. </td></tr>
    <tr><td class="paramname">m0</td><td>A n x 1 matrix. The mean vector of the distribution of the initial state. </td></tr>
    <tr><td class="paramname">C0</td><td>A n x n matrix. The covariance matrix of the distribution of the initial state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the joint density of the GDLM. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if a matrix in the Kalman filter is not positive semi-definite.</td></tr>
  </table>
  </dd>
</dl>
<p>This distribution is equivalent to, for \(t = 1:T\), </p><p class="formulaDsp">
\begin{eqnarray*} y_t &amp; \sim N(F&#39; \theta_t, diag(V)) \\ \theta_t &amp; \sim N(G \theta_{t-1}, W) \\ \theta_0 &amp; \sim N(m_0, C_0) \end{eqnarray*}
</p>
<p>If V is a vector, then the Kalman filter is applied sequentially.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A r x T matrix of observations. Rows are variables, columns are observations. </td></tr>
    <tr><td class="paramname">F</td><td>A n x r matrix. The design matrix. </td></tr>
    <tr><td class="paramname">G</td><td>A n x n matrix. The transition matrix. </td></tr>
    <tr><td class="paramname">V</td><td>A size r vector. The diagonal of the observation covariance matrix. </td></tr>
    <tr><td class="paramname">W</td><td>A n x n matrix. The state covariance matrix. </td></tr>
    <tr><td class="paramname">m0</td><td>A n x 1 matrix. The mean vector of the distribution of the initial state. </td></tr>
    <tr><td class="paramname">C0</td><td>A n x n matrix. The covariance matrix of the distribution of the initial state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the joint density of the GDLM. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if a matrix in the Kalman filter is not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_F</td><td>Type of design matrix. </td></tr>
    <tr><td class="paramname">T_G</td><td>Type of transition matrix. </td></tr>
    <tr><td class="paramname">T_V</td><td>Type of observation variances </td></tr>
    <tr><td class="paramname">T_W</td><td>Type of state covariance matrix. </td></tr>
    <tr><td class="paramname">T_m0</td><td>Type of initial state mean vector. </td></tr>
    <tr><td class="paramname">T_C0</td><td>Type of initial state covariance matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../db/d67/gaussian__dlm__obs__lpdf_8hpp_source.html#l00070">70</a> of file <a class="el" href="../../db/d67/gaussian__dlm__obs__lpdf_8hpp_source.html">gaussian_dlm_obs_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga38ce72e12b0f414f6c82f82f492db728"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd stan::math::gaussian_dlm_obs_rng </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>m0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>C0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simulate random draw from Gaussian dynamic linear model (GDLM). </p>
<p>This distribution is equivalent to, for \(t = 1:T\), </p><p class="formulaDsp">
\begin{eqnarray*} y_t &amp; \sim N(F&#39; \theta_t, V) \\ \theta_t &amp; \sim N(G \theta_{t-1}, W) \\ \theta_0 &amp; \sim N(m_0, C_0) \end{eqnarray*}
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RNG</td><td>Type of pseudo-random number generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>A n x r matrix. The design matrix. </td></tr>
    <tr><td class="paramname">G</td><td>A n x n matrix. The transition matrix. </td></tr>
    <tr><td class="paramname">V</td><td>A r x r matrix. The observation covariance matrix. </td></tr>
    <tr><td class="paramname">W</td><td>A n x n matrix. The state covariance matrix. </td></tr>
    <tr><td class="paramname">m0</td><td>A n x 1 matrix. The mean vector of the distribution of the initial state. </td></tr>
    <tr><td class="paramname">C0</td><td>A n x n matrix. The covariance matrix of the distribution of the initial state. </td></tr>
    <tr><td class="paramname">T</td><td>a positive integer, how many timesteps to simulate. </td></tr>
    <tr><td class="paramname">rng</td><td>Pseudo-random number generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A r x T matrix of simulated observations. Rows are variables, columns are observations. First column is the state after the first transition. Last column is the state after the last transition. Initial state not returned. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if a matrix is not symmetric or not positive semi-definite. Or throw std::invalid_argument if a size is wrong or any input is NaN or non-finite, or if T is not positive. Require C0 in particular to be strictly positive definite. V and W can be semidefinite. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../db/ddb/gaussian__dlm__obs__rng_8hpp_source.html#l00088">88</a> of file <a class="el" href="../../db/ddb/gaussian__dlm__obs__rng_8hpp_source.html">gaussian_dlm_obs_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaa40f6b9636708f5cf52428890f2b62c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_dof , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_dof, T_scale&gt; stan::math::inv_wishart_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the Inverse-Wishart density for the given W, degrees of freedom, and scale matrix. </p>
<p>The scale matrix, S, must be k x k, symmetric, and semi-positive definite.</p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000091">Deprecated:</a></b></dt><dd>use <code>inverse_wishart_lpdf</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">W</td><td>A scalar matrix </td></tr>
    <tr><td class="paramname">nu</td><td>Degrees of freedom </td></tr>
    <tr><td class="paramname">S</td><td>The scale matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the Inverse-Wishart density at W given nu and S. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than k-1 </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if S is not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_dof</td><td>Type of degrees of freedom. </td></tr>
    <tr><td class="paramname">T_scale</td><td>Type of scale. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/d68/inv__wishart__log_8hpp_source.html#l00032">32</a> of file <a class="el" href="../../d5/d68/inv__wishart__log_8hpp_source.html">inv_wishart_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7b83a2e763ad50ebace73c003cdffee2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_dof, T_scale&gt; stan::math::inv_wishart_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000092">Deprecated:</a></b></dt><dd>use <code>inverse_wishart_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d5/d68/inv__wishart__log_8hpp_source.html#l00042">42</a> of file <a class="el" href="../../d5/d68/inv__wishart__log_8hpp_source.html">inv_wishart_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga3bab1543379d2e07160d395b2e0a832c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_dof , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_dof, T_scale&gt; stan::math::inv_wishart_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the Inverse-Wishart density for the given W, degrees of freedom, and scale matrix. </p>
<p>The scale matrix, S, must be k x k, symmetric, and semi-positive definite.</p>
<p class="formulaDsp">
\begin{eqnarray*} W &amp;\sim&amp; \mbox{\sf{Inv-Wishart}}_{\nu} (S) \\ \log (p (W \, |\, \nu, S) ) &amp;=&amp; \log \left( \left(2^{\nu k/2} \pi^{k (k-1) /4} \prod_{i=1}^k{\Gamma (\frac{\nu + 1 - i}{2})} \right)^{-1} \times \left| S \right|^{\nu/2} \left| W \right|^{-(\nu + k + 1) / 2} \times \exp (-\frac{1}{2} \mbox{tr} (S W^{-1})) \right) \\ &amp;=&amp; -\frac{\nu k}{2}\log(2) - \frac{k (k-1)}{4} \log(\pi) - \sum_{i=1}^{k}{\log (\Gamma (\frac{\nu+1-i}{2}))} +\frac{\nu}{2} \log(\det(S)) - \frac{\nu+k+1}{2}\log (\det(W)) - \frac{1}{2} \mbox{tr}(S W^{-1}) \end{eqnarray*}
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_dof</td><td>type of degrees of freedom </td></tr>
    <tr><td class="paramname">T_scale</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">W</td><td>A scalar matrix </td></tr>
    <tr><td class="paramname">nu</td><td>Degrees of freedom </td></tr>
    <tr><td class="paramname">S</td><td>The scale matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the Inverse-Wishart density at W given nu and S. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than k-1 </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if S is not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d8/d4e/inv__wishart__lpdf_8hpp_source.html#l00045">45</a> of file <a class="el" href="../../d8/d4e/inv__wishart__lpdf_8hpp_source.html">inv_wishart_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gad4f34ffe4fb4185f64f05b28899bf1be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_covar , typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_covar, T_shape&gt; stan::math::lkj_corr_cholesky_log </td>
          <td>(</td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>eta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000093">Deprecated:</a></b></dt><dd>use <code>lkj_corr_cholesky_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../de/d5f/lkj__corr__cholesky__log_8hpp_source.html#l00015">15</a> of file <a class="el" href="../../de/d5f/lkj__corr__cholesky__log_8hpp_source.html">lkj_corr_cholesky_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaf932f9050e5cd92af767842e35978ec9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_covar , typename T_shape &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_covar, T_shape&gt; stan::math::lkj_corr_cholesky_log </td>
          <td>(</td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>eta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000094">Deprecated:</a></b></dt><dd>use <code>lkj_corr_cholesky_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../de/d5f/lkj__corr__cholesky__log_8hpp_source.html#l00024">24</a> of file <a class="el" href="../../de/d5f/lkj__corr__cholesky__log_8hpp_source.html">lkj_corr_cholesky_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga42a03d6d4728db20bc6ba51f6890004f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_shape&gt; stan::math::lkj_corr_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>eta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000095">Deprecated:</a></b></dt><dd>use <code>lkj_corr_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d6/df9/lkj__corr__log_8hpp_source.html#l00015">15</a> of file <a class="el" href="../../d6/df9/lkj__corr__log_8hpp_source.html">lkj_corr_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae537974c3f5c4d51df02883faf940514"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_shape &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_shape&gt; stan::math::lkj_corr_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>eta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000096">Deprecated:</a></b></dt><dd>use <code>lkj_corr_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d6/df9/lkj__corr__log_8hpp_source.html#l00023">23</a> of file <a class="el" href="../../d6/df9/lkj__corr__log_8hpp_source.html">lkj_corr_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga5570fda8e3d07213840dc2a9f4155e18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd stan::math::lkj_corr_rng </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a random correlation matrix (symmetric, positive definite, unit diagonal) of the specified dimensionality drawn from the LKJ distribution with the specified degrees of freedom using the specified random number generator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RNG</td><td>Random number generator type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>Number of rows and columns of generated matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eta</td><td>Degrees of freedom for LKJ distribution. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rng</td><td>Random-number generator to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random variate with specified distribution. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the shape parameter is not positive. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d7/d84/lkj__corr__rng_8hpp_source.html#l00026">26</a> of file <a class="el" href="../../d7/d84/lkj__corr__rng_8hpp_source.html">lkj_corr_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaf76c55d89307f751df515b9b11df006c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_loc, T_scale, T_shape&gt; stan::math::lkj_cov_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>eta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000097">Deprecated:</a></b></dt><dd>use <code>lkj_cov_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d3/d25/lkj__cov__log_8hpp_source.html#l00016">16</a> of file <a class="el" href="../../d3/d25/lkj__cov__log_8hpp_source.html">lkj_cov_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga1263a19d3a44357832c1baafe3fb4df2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_loc, T_scale, T_shape&gt; stan::math::lkj_cov_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>eta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000098">Deprecated:</a></b></dt><dd>use <code>lkj_cov_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d3/d25/lkj__cov__log_8hpp_source.html#l00025">25</a> of file <a class="el" href="../../d3/d25/lkj__cov__log_8hpp_source.html">lkj_cov_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga64262a3799093d51c79227c7ef409094"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_Mu , typename T_Sigma , typename T_D , require_all_matrix_t&lt; T_y, T_Mu, T_Sigma, T_D &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_Mu, T_Sigma, T_D&gt; stan::math::matrix_normal_prec_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Mu &amp;&#160;</td>
          <td class="paramname"><em>Mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Sigma &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_D &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the matrix normal density for the given y, mu, Sigma and D where Sigma and D are given as precision matrices, not covariance matrices. </p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000110">Deprecated:</a></b></dt><dd>use <code>matrix_normal_prec_lpdf</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>An mxn matrix. </td></tr>
    <tr><td class="paramname">Mu</td><td>The mean matrix. </td></tr>
    <tr><td class="paramname">Sigma</td><td>The mxm inverse covariance matrix (i.e., the precision matrix) of the rows of y. </td></tr>
    <tr><td class="paramname">D</td><td>The nxn inverse covariance matrix (i.e., the precision matrix) of the columns of y. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the matrix normal density. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if Sigma or D are not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_Mu</td><td>Type of location. </td></tr>
    <tr><td class="paramname">T_Sigma</td><td>Type of Sigma. </td></tr>
    <tr><td class="paramname">T_D</td><td>Type of D. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/d3a/matrix__normal__prec__log_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../d5/d3a/matrix__normal__prec__log_8hpp_source.html">matrix_normal_prec_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gab7c0d07cf387dd011b3d244907813488"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_Mu , typename T_Sigma , typename T_D , require_all_matrix_t&lt; T_y, T_Mu, T_Sigma, T_D &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_Mu, T_Sigma, T_D&gt; stan::math::matrix_normal_prec_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Mu &amp;&#160;</td>
          <td class="paramname"><em>Mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Sigma &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_D &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000111">Deprecated:</a></b></dt><dd>use <code>matrix_normal_prec_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d5/d3a/matrix__normal__prec__log_8hpp_source.html#l00045">45</a> of file <a class="el" href="../../d5/d3a/matrix__normal__prec__log_8hpp_source.html">matrix_normal_prec_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gafacda7490d4f642b087dbf55274bcb9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_Mu , typename T_Sigma , typename T_D , require_all_matrix_t&lt; T_y, T_Mu, T_Sigma, T_D &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_Mu, T_Sigma, T_D&gt; stan::math::matrix_normal_prec_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Mu &amp;&#160;</td>
          <td class="paramname"><em>Mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Sigma &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_D &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the matrix normal density for the given y, mu, Sigma and D where Sigma and D are given as precision matrices, not covariance matrices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_Mu</td><td>type of location </td></tr>
    <tr><td class="paramname">T_Sigma</td><td>type of Sigma </td></tr>
    <tr><td class="paramname">T_D</td><td>type of D</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>An mxn matrix. </td></tr>
    <tr><td class="paramname">Mu</td><td>The mean matrix. </td></tr>
    <tr><td class="paramname">Sigma</td><td>The mxm inverse covariance matrix (i.e., the precision matrix) of the rows of y. </td></tr>
    <tr><td class="paramname">D</td><td>The nxn inverse covariance matrix (i.e., the precision matrix) of the columns of y. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the matrix normal density. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if Sigma or D are not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d8/df3/matrix__normal__prec__lpdf_8hpp_source.html#l00036">36</a> of file <a class="el" href="../../d8/df3/matrix__normal__prec__lpdf_8hpp_source.html">matrix_normal_prec_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga3e4ff308feab4aaf90dd7036f85667d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd stan::math::matrix_normal_prec_rng </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>Mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample from the the matrix normal distribution for the given Mu, Sigma and D where Sigma and D are given as precision matrices, not covariance matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mu</td><td>The mean matrix. </td></tr>
    <tr><td class="paramname">Sigma</td><td>The mxm inverse covariance matrix (i.e., the precision matrix) of the rows of y. </td></tr>
    <tr><td class="paramname">D</td><td>The nxn inverse covariance matrix (i.e., the precision matrix) of the columns of y. </td></tr>
    <tr><td class="paramname">rng</td><td>Pseudo-random number generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sample from the distribution, of type Matrix&lt;double, Dynamic, Dynamic&gt;. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if Sigma or D are not square. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if Sigma or D are not symmetric, not semi-positive definite, or if they contain infinities or NaNs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RNG</td><td>Type of pseudo-random number generator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../df/dbd/matrix__normal__prec__rng_8hpp_source.html#l00032">32</a> of file <a class="el" href="../../df/dbd/matrix__normal__prec__rng_8hpp_source.html">matrix_normal_prec_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga92e43d15693f5421f3a8a85b903e8a22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_covar , typename T_w &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_covar, T_w&gt; stan::math::multi_gp_cholesky_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_w &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of a multivariate Gaussian Process for the given y, w, and a Cholesky factor L of the kernel matrix Sigma. </p>
<p>Sigma = LL', a square, semi-positive definite matrix. y is a dxN matrix, where each column is a different observation and each row is a different output dimension. The Gaussian Process is assumed to have a scaled kernel matrix with a different scale for each output dimension. This distribution is equivalent to: for (i in 1:d) row(y, i) ~ multi_normal(0, (1/w[i])*LL').</p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000112">Deprecated:</a></b></dt><dd>use <code>multi_gp_cholesky_lpdf</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A dxN matrix </td></tr>
    <tr><td class="paramname">L</td><td>The Cholesky decomposition of a kernel matrix </td></tr>
    <tr><td class="paramname">w</td><td>A d-dimensional vector of positive inverse scale parameters for each output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the multivariate GP density. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if Sigma is not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_covar</td><td>Type of kernel. </td></tr>
    <tr><td class="paramname">T_w</td><td>Type of weight. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/d71/multi__gp__cholesky__log_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../d5/d71/multi__gp__cholesky__log_8hpp_source.html">multi_gp_cholesky_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga80d0035ddc21ae34c30faeee40995456"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_covar , typename T_w &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_covar, T_w&gt; stan::math::multi_gp_cholesky_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_w &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000113">Deprecated:</a></b></dt><dd>use <code>multi_gp_cholesky_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d5/d71/multi__gp__cholesky__log_8hpp_source.html#l00044">44</a> of file <a class="el" href="../../d5/d71/multi__gp__cholesky__log_8hpp_source.html">multi_gp_cholesky_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gac52b7477faba2eb49537ec31d4d5461f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_covar , typename T_w , require_all_eigen_matrix_dynamic_t&lt; T_y, T_covar &gt; *  = nullptr, require_eigen_col_vector_t&lt; T_w &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_covar, T_w&gt; stan::math::multi_gp_cholesky_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_w &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of a multivariate Gaussian Process for the given y, w, and a Cholesky factor L of the kernel matrix Sigma. </p>
<p>Sigma = LL', a square, semi-positive definite matrix. y is a dxN matrix, where each column is a different observation and each row is a different output dimension. The Gaussian Process is assumed to have a scaled kernel matrix with a different scale for each output dimension. This distribution is equivalent to: for (i in 1:d) row(y, i) ~ multi_normal(0, (1/w[i])*LL').</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_covar</td><td>type of kernel </td></tr>
    <tr><td class="paramname">T_w</td><td>type of weight</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A dxN matrix </td></tr>
    <tr><td class="paramname">L</td><td>The Cholesky decomposition of a kernel matrix </td></tr>
    <tr><td class="paramname">w</td><td>A d-dimensional vector of positive inverse scale parameters for each output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the multivariate GP density. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if Sigma is not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d73/multi__gp__cholesky__lpdf_8hpp_source.html#l00041">41</a> of file <a class="el" href="../../dd/d73/multi__gp__cholesky__lpdf_8hpp_source.html">multi_gp_cholesky_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gac395a822d38d24a39ef02e695435c7f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_covar , typename T_w &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_covar, T_w&gt; stan::math::multi_gp_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_w &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of a multivariate Gaussian Process for the given y, Sigma, and w. </p>
<p>y is a dxN matrix, where each column is a different observation and each row is a different output dimension. The Gaussian Process is assumed to have a scaled kernel matrix with a different scale for each output dimension. This distribution is equivalent to: for (i in 1:d) row(y, i) ~ multi_normal(0, (1/w[i])*Sigma).</p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000114">Deprecated:</a></b></dt><dd>use <code>multi_gp_lpdf</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A dxN matrix </td></tr>
    <tr><td class="paramname">Sigma</td><td>The NxN kernel matrix </td></tr>
    <tr><td class="paramname">w</td><td>A d-dimensional vector of positive inverse scale parameters for each output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the multivariate GP density. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if Sigma is not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_covar</td><td>Type of kernel. </td></tr>
    <tr><td class="paramname">T_w</td><td>Type of weight. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/ddb/multi__gp__log_8hpp_source.html#l00033">33</a> of file <a class="el" href="../../dd/ddb/multi__gp__log_8hpp_source.html">multi_gp_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaaa0a8ceba99d5354ab0fa1fc385b44e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_covar , typename T_w &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_covar, T_w&gt; stan::math::multi_gp_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_w &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000115">Deprecated:</a></b></dt><dd>use <code>multi_gp_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../dd/ddb/multi__gp__log_8hpp_source.html#l00043">43</a> of file <a class="el" href="../../dd/ddb/multi__gp__log_8hpp_source.html">multi_gp_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga0d9a55dfe7ed454e7972010da608c530"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_covar , typename T_w , require_all_matrix_t&lt; T_y, T_covar &gt; *  = nullptr, require_col_vector_t&lt; T_w &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_covar, T_w&gt; stan::math::multi_gp_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_w &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of a multivariate Gaussian Process for the given y, Sigma, and w. </p>
<p>y is a dxN matrix, where each column is a different observation and each row is a different output dimension. The Gaussian Process is assumed to have a scaled kernel matrix with a different scale for each output dimension. This distribution is equivalent to: for (i in 1:d) row(y, i) ~ multi_normal(0, (1/w[i])*Sigma).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_covar</td><td>type of kernel </td></tr>
    <tr><td class="paramname">T_w</td><td>type of weight </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A dxN matrix </td></tr>
    <tr><td class="paramname">Sigma</td><td>The NxN kernel matrix </td></tr>
    <tr><td class="paramname">w</td><td>A d-dimensional vector of positive inverse scale parameters for each output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the multivariate GP density. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if Sigma is not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d8/dcc/multi__gp__lpdf_8hpp_source.html#l00036">36</a> of file <a class="el" href="../../d8/dcc/multi__gp__lpdf_8hpp_source.html">multi_gp_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gace251fa4176a6620b0cc601eea04c0c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_covar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_loc, T_covar&gt; stan::math::multi_normal_cholesky_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the multivariate normal density for the given y, mu, and a Cholesky factor L of the variance matrix. </p>
<p>Sigma = LL', a square, semi-positive definite matrix.</p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000116">Deprecated:</a></b></dt><dd>use <code>multi_normal_cholesky_lpdf</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar vector </td></tr>
    <tr><td class="paramname">mu</td><td>The mean vector of the multivariate normal distribution. </td></tr>
    <tr><td class="paramname">L</td><td>The Cholesky decomposition of a variance matrix of the multivariate normal distribution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the multivariate normal density. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if LL' is not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_loc</td><td>Type of location. </td></tr>
    <tr><td class="paramname">T_covar</td><td>Type of scale. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dc/dfd/multi__normal__cholesky__log_8hpp_source.html#l00029">29</a> of file <a class="el" href="../../dc/dfd/multi__normal__cholesky__log_8hpp_source.html">multi_normal_cholesky_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga6ee11ca85a43b351e4d8975a665f6328"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_covar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_loc, T_covar&gt; stan::math::multi_normal_cholesky_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000117">Deprecated:</a></b></dt><dd>use <code>multi_normal_cholesky_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../dc/dfd/multi__normal__cholesky__log_8hpp_source.html#l00039">39</a> of file <a class="el" href="../../dc/dfd/multi__normal__cholesky__log_8hpp_source.html">multi_normal_cholesky_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga5e547a39d62c5161c0908d94cd53c992"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_covar , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_covar &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_loc, T_covar&gt; stan::math::multi_normal_cholesky_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the multivariate normal density for the given y, mu, and a Cholesky factor L of the variance matrix. </p>
<p>Sigma = LL', a square, semi-positive definite matrix.</p>
<p>Analytic expressions taken from <a href="http://qwone.com/~jason/writing/multivariateNormal.pdf">http://qwone.com/~jason/writing/multivariateNormal.pdf</a> written by Jason D. M. Rennie.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar vector </td></tr>
    <tr><td class="paramname">mu</td><td>The mean vector of the multivariate normal distribution. </td></tr>
    <tr><td class="paramname">L</td><td>The Cholesky decomposition of a variance matrix of the multivariate normal distribution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the multivariate normal density. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if LL' is not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_loc</td><td>Type of location. </td></tr>
    <tr><td class="paramname">T_covar</td><td>Type of scale. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../da/df7/prim_2prob_2multi__normal__cholesky__lpdf_8hpp_source.html#l00044">44</a> of file <a class="el" href="../../da/df7/prim_2prob_2multi__normal__cholesky__lpdf_8hpp_source.html">multi_normal_cholesky_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga8768d74289b60b1a89cfc60050e137d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_loc , class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StdVectorBuilder&lt;true, Eigen::VectorXd, T_loc&gt;::type stan::math::multi_normal_cholesky_rng </td>
          <td>(</td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a multivariate normal random variate with the given location and Cholesky factorization of the covariance using the specified random number generator. </p>
<p>mu can be either an Eigen::VectorXd, an Eigen::RowVectorXd, or a std::vector of either of those types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_loc</td><td>Type of location parameter </td></tr>
    <tr><td class="paramname">RNG</td><td>Type of pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mu</td><td>(Sequence of) location parameter(s) </td></tr>
    <tr><td class="paramname">L</td><td>Lower Cholesky factor of target covariance matrix </td></tr>
    <tr><td class="paramname">rng</td><td>random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the length of (each) mu is not equal to the number of rows and columns in L </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d9/dc2/multi__normal__cholesky__rng_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../d9/dc2/multi__normal__cholesky__rng_8hpp_source.html">multi_normal_cholesky_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaea7c9f516fd2163ec5021d2731b6a18a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_covar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_loc, T_covar&gt; stan::math::multi_normal_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000118">Deprecated:</a></b></dt><dd>use <code>matrix_normal_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d4/d01/multi__normal__log_8hpp_source.html#l00014">14</a> of file <a class="el" href="../../d4/d01/multi__normal__log_8hpp_source.html">multi_normal_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga46e1d2d523388bc94abb1d7925c10643"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_covar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_loc, T_covar&gt; stan::math::multi_normal_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000119">Deprecated:</a></b></dt><dd>use <code>matrix_normal_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d4/d01/multi__normal__log_8hpp_source.html#l00024">24</a> of file <a class="el" href="../../d4/d01/multi__normal__log_8hpp_source.html">multi_normal_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae01340614eb63292b100327af71f2626"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_covar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_loc, T_covar&gt; stan::math::multi_normal_prec_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000120">Deprecated:</a></b></dt><dd>use <code>multi_normal_prec_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d8/d8f/multi__normal__prec__log_8hpp_source.html#l00014">14</a> of file <a class="el" href="../../d8/d8f/multi__normal__prec__log_8hpp_source.html">multi_normal_prec_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gad8a791079717a70af1ceb21d240c85df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_covar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_loc, T_covar&gt; stan::math::multi_normal_prec_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000121">Deprecated:</a></b></dt><dd>use <code>multi_normal_prec_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d8/d8f/multi__normal__prec__log_8hpp_source.html#l00024">24</a> of file <a class="el" href="../../d8/d8f/multi__normal__prec__log_8hpp_source.html">multi_normal_prec_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gadc2a15a609c6e3967046385e6c411041"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_loc , class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StdVectorBuilder&lt;true, Eigen::VectorXd, T_loc&gt;::type stan::math::multi_normal_prec_rng </td>
          <td>(</td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a multivariate normal random variate with the given location and precision using the specified random number generator. </p>
<p>mu can be either an Eigen::VectorXd, an Eigen::RowVectorXd, or a std::vector of either of those types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_loc</td><td>Type of location parameter </td></tr>
    <tr><td class="paramname">RNG</td><td>Type of pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mu</td><td>(Sequence of) location parameter(s) </td></tr>
    <tr><td class="paramname">S</td><td>Precision matrix </td></tr>
    <tr><td class="paramname">rng</td><td>random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if S is not positive definite, or std::invalid_argument if the length of (each) mu is not equal to the number of rows and columns in S </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d4/d28/multi__normal__prec__rng_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../d4/d28/multi__normal__prec__rng_8hpp_source.html">multi_normal_prec_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga8d5464fa79ab08a7731cef29ded7e384"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_loc , class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StdVectorBuilder&lt;true, Eigen::VectorXd, T_loc&gt;::type stan::math::multi_normal_rng </td>
          <td>(</td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a multivariate normal random variate with the given location and covariance using the specified random number generator. </p>
<p>mu can be either an Eigen::VectorXd, an Eigen::RowVectorXd, or a std::vector of either of those types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_loc</td><td>Type of location parameter </td></tr>
    <tr><td class="paramname">RNG</td><td>Type of pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mu</td><td>(Sequence of) location parameter(s) </td></tr>
    <tr><td class="paramname">S</td><td>Covariance matrix </td></tr>
    <tr><td class="paramname">rng</td><td>random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if S is not positive definite, or std::invalid_argument if the length of (each) mu is not equal to the number of rows and columns in S </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../da/d7d/multi__normal__rng_8hpp_source.html#l00034">34</a> of file <a class="el" href="../../da/d7d/multi__normal__rng_8hpp_source.html">multi_normal_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gad26dd2ec37297ebe230eadae53025d19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd stan::math::internal::multi_normal_semidefinite_rng </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::LDLT&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>S_ldlt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a multivariate normal random variate with the given location and covariance using the specified random number generator. </p>
<p>No error checking or templating, takes the LDLT directly to avoid recomputation. Can sample from semidefinite covariance matrices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RNG</td><td>type of pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mu</td><td>location parameter </td></tr>
    <tr><td class="paramname">S_ldlt</td><td>Eigen::LDLT of covariance matrix, semidefinite is okay </td></tr>
    <tr><td class="paramname">rng</td><td>random number generator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../db/ddb/gaussian__dlm__obs__rng_8hpp_source.html#l00029">29</a> of file <a class="el" href="../../db/ddb/gaussian__dlm__obs__rng_8hpp_source.html">gaussian_dlm_obs_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga5ad01e45f4c8eabe5c813e0cc4eece98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_dof, T_loc, T_scale&gt; stan::math::multi_student_t_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the log of the multivariate Student t distribution at the specified arguments. </p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000122">Deprecated:</a></b></dt><dd>use <code>multi_student_t_lpdf</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propto</td><td>Carry out calculations up to a proportion </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../df/dbe/multi__student__t__log_8hpp_source.html#l00020">20</a> of file <a class="el" href="../../df/dbe/multi__student__t__log_8hpp_source.html">multi_student_t_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga21dabf2487a3e696c03c2faada3a6e92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_dof, T_loc, T_scale&gt; stan::math::multi_student_t_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000123">Deprecated:</a></b></dt><dd>use <code>multi_student_t_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../df/dbe/multi__student__t__log_8hpp_source.html#l00030">30</a> of file <a class="el" href="../../df/dbe/multi__student__t__log_8hpp_source.html">multi_student_t_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga95c2aa50c01a2eb18d3ec107fb58fabc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_dof, T_loc, T_scale&gt; stan::math::multi_student_t_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the log of the multivariate Student t distribution at the specified arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propto</td><td>Carry out calculations up to a proportion </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/d66/multi__student__t__lpdf_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../d5/d66/multi__student__t__lpdf_8hpp_source.html">multi_student_t_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga098f5cc8afde056925944720d5295fd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_loc , class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StdVectorBuilder&lt;true, Eigen::VectorXd, T_loc&gt;::type stan::math::multi_student_t_rng </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a multivariate student-t random variate with the given degrees of freedom location and covariance using the specified random number generator. </p>
<p>mu can be either an Eigen::VectorXd, an Eigen::RowVectorXd, or a std::vector of either of those types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_loc</td><td>Type of location parameter </td></tr>
    <tr><td class="paramname">RNG</td><td>Type of pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nu</td><td>degrees of freedom parameter </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location parameter(s) </td></tr>
    <tr><td class="paramname">S</td><td>Covariance matrix </td></tr>
    <tr><td class="paramname">rng</td><td>random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if S is not positive definite, any value in mu is not finite, nu is not positive, or nu is NaN </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the length of (each) mu is not equal to the number of rows and columns in S </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d0/d6d/multi__student__t__rng_8hpp_source.html#l00038">38</a> of file <a class="el" href="../../d0/d6d/multi__student__t__rng_8hpp_source.html">multi_student_t_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaec16418a01064477e58f33a044043016"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_prob&gt; stan::math::multinomial_log </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000124">Deprecated:</a></b></dt><dd>use <code>multinomial_lpmf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d1/d7c/multinomial__log_8hpp_source.html#l00016">16</a> of file <a class="el" href="../../d1/d7c/multinomial__log_8hpp_source.html">multinomial_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gab017f8f0887aa6c9a2ca92e5a4a2a1ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_prob&gt; stan::math::multinomial_log </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000125">Deprecated:</a></b></dt><dd>use <code>multinomial_lpmf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d1/d7c/multinomial__log_8hpp_source.html#l00025">25</a> of file <a class="el" href="../../d1/d7c/multinomial__log_8hpp_source.html">multinomial_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gafbefda25fc43e26d3a5d2818bb086dd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_beta , require_eigen_col_vector_t&lt; T_beta &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_beta&gt; stan::math::multinomial_logit_log </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000126">Deprecated:</a></b></dt><dd>use <code>multinomial_logit_lpmf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d8/db3/multinomial__logit__log_8hpp_source.html#l00017">17</a> of file <a class="el" href="../../d8/db3/multinomial__logit__log_8hpp_source.html">multinomial_logit_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4fb6cb28e7a16a526f9467941e6cf88e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_beta , require_eigen_col_vector_t&lt; T_beta &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_beta&gt; stan::math::multinomial_logit_log </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000127">Deprecated:</a></b></dt><dd>use <code>multinomial_logit_lpmf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d8/db3/multinomial__logit__log_8hpp_source.html#l00026">26</a> of file <a class="el" href="../../d8/db3/multinomial__logit__log_8hpp_source.html">multinomial_logit_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaabe7d1ac7913e83814c3294d996e91c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_beta , typename T_prob  = scalar_type_t&lt;T_beta&gt;, require_eigen_col_vector_t&lt; T_beta &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_prob&gt; stan::math::multinomial_logit_lpmf </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multinomial log PMF in log parametrization. </p>
<p>Multinomial(ns| softmax(beta))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Array of outcome counts </td></tr>
    <tr><td class="paramname">beta</td><td>Vector of unnormalized log probabilities </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability </dd></dl>

<p>Definition at line <a class="el" href="../../dc/d23/multinomial__logit__lpmf_8hpp_source.html#l00025">25</a> of file <a class="el" href="../../dc/d23/multinomial__logit__lpmf_8hpp_source.html">multinomial_logit_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga04d59be2c49c48a314b727ee2e3831cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG , typename T_beta , require_eigen_col_vector_t&lt; T_beta &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; stan::math::multinomial_logit_rng </td>
          <td>(</td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a draw from a Multinomial distribution given a a vector of unnormalized log probabilities and a pseudo-random number generator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RNG</td><td>Type of pseudo-random number generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beta</td><td>Vector of unnormalized log probabilities. </td></tr>
    <tr><td class="paramname">N</td><td>Total count </td></tr>
    <tr><td class="paramname">rng</td><td>Pseudo-random number generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Multinomial random variate </dd></dl>

<p>Definition at line <a class="el" href="../../d8/d33/multinomial__logit__rng_8hpp_source.html#l00027">27</a> of file <a class="el" href="../../d8/d33/multinomial__logit__rng_8hpp_source.html">multinomial_logit_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9ec367ab511061785e827db08b413fee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_precision &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_x, T_alpha, T_beta, T_precision&gt; stan::math::neg_binomial_2_log_glm_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_precision &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000132">Deprecated:</a></b></dt><dd>use <code>neg_binomial_2_log_glm_lpmf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d4/d49/neg__binomial__2__log__glm__log_8hpp_source.html#l00015">15</a> of file <a class="el" href="../../d4/d49/neg__binomial__2__log__glm__log_8hpp_source.html">neg_binomial_2_log_glm_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga28bbe881fe2967522f7ea474c7f3cab1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_precision &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_x, T_alpha, T_beta, T_precision&gt; stan::math::neg_binomial_2_log_glm_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_precision &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000133">Deprecated:</a></b></dt><dd>use <code>poisson_logit_glm_lpmf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d4/d49/neg__binomial__2__log__glm__log_8hpp_source.html#l00028">28</a> of file <a class="el" href="../../d4/d49/neg__binomial__2__log__glm__log_8hpp_source.html">neg_binomial_2_log_glm_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gab5c3fd7ac58ea81db866febba20fec6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_precision , require_eigen_t&lt; T_x &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_x, T_alpha, T_beta, T_precision&gt; stan::math::neg_binomial_2_log_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_precision &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the Generalized Linear Model (GLM) with Negative-Binomial-2 distribution and log link function. </p>
<p>The idea is that neg_binomial_2_log_glm_lpmf(y, x, alpha, beta, phi) should compute a more efficient version of neg_binomial_2_log_lpmf(y, alpha + x * beta, phi) by using analytically simplified gradients. If containers are supplied, returns the log sum of the probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>type of positive int vector of variates (labels); this can also be a single positive integer value; </td></tr>
    <tr><td class="paramname">T_x_scalar</td><td>type of a scalar in the matrix of independent variables (features) </td></tr>
    <tr><td class="paramname">T_x_rows</td><td>compile-time number of rows of <code>x</code>. It can be either <code>Eigen::Dynamic</code> or 1. </td></tr>
    <tr><td class="paramname">T_alpha</td><td>type of the intercept(s); this can be a vector (of the same length as y) of intercepts or a single value (for models with constant intercept); </td></tr>
    <tr><td class="paramname">T_beta</td><td>type of the weight vector; this can also be a scalar; </td></tr>
    <tr><td class="paramname">T_precision</td><td>type of the (positive) precision(s); this can be a vector (of the same length as y, for heteroskedasticity) or a scalar.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>failures count scalar or vector parameter. If it is a scalar it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">x</td><td>design matrix or row vector. If it is a row vector it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
    <tr><td class="paramname">phi</td><td>(vector of) precision parameter(s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if x, beta or alpha is infinite. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if phi is infinite or non-positive. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is negative. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../df/d11/prim_2prob_2neg__binomial__2__log__glm__lpmf_8hpp_source.html#l00066">66</a> of file <a class="el" href="../../df/d11/prim_2prob_2neg__binomial__2__log__glm__lpmf_8hpp_source.html">neg_binomial_2_log_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4473e11ac43137c4e42f785b610f070b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_x, T_alpha, T_beta, T_scale&gt; stan::math::normal_id_glm_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000142">Deprecated:</a></b></dt><dd>use <code>normal_id_glm_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d7/de3/normal__id__glm__log_8hpp_source.html#l00015">15</a> of file <a class="el" href="../../d7/de3/normal__id__glm__log_8hpp_source.html">normal_id_glm_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga57b3d600f49fc423fa936b7fa3c9e379"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_x, T_alpha, T_beta, T_scale&gt; stan::math::normal_id_glm_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000143">Deprecated:</a></b></dt><dd>use <code>normal_id_glm_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d7/de3/normal__id__glm__log_8hpp_source.html#l00027">27</a> of file <a class="el" href="../../d7/de3/normal__id__glm__log_8hpp_source.html">normal_id_glm_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga5abfa04756222a7b66c2567d12182aea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_scale , require_eigen_t&lt; T_x &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_x, T_alpha, T_beta, T_scale&gt; stan::math::normal_id_glm_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PDF of the Generalized Linear Model (GLM) with Normal distribution and id link function. </p>
<p>If containers are supplied, returns the log sum of the probabilities. The idea is that normal_id_glm_lpdf(y, x, alpha, beta, sigma) should compute a more efficient version of normal_lpdf(y, alpha + x * beta, sigma) by using analytically simplified gradients.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>type of vector of dependent variables (labels); </td></tr>
    <tr><td class="paramname">T_x</td><td>type of the matrix of independent variables (features) </td></tr>
    <tr><td class="paramname">T_alpha</td><td>type of the intercept(s); this can be a vector (of the same length as y) of intercepts or a single value (for models with constant intercept); </td></tr>
    <tr><td class="paramname">T_beta</td><td>type of the weight vector; this can also be a single value; </td></tr>
    <tr><td class="paramname">T_scale</td><td>type of the (positive) scale(s); this can be a vector (of the same length as y, for heteroskedasticity) or a scalar.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>scalar or vector of dependent variables. If it is a scalar it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">x</td><td>design matrix or row vector. If it is a row vector it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale parameters for the normal distribution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if x, beta or alpha is infinite. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if the scale is not positive. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../de/d31/prim_2prob_2normal__id__glm__lpdf_8hpp_source.html#l00055">55</a> of file <a class="el" href="../../de/d31/prim_2prob_2normal__id__glm__lpdf_8hpp_source.html">normal_id_glm_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gace9b0f885af3060f53d14e9e113729fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_x , typename T_beta , typename T_cuts , require_eigen_t&lt; T_x &gt; *  = nullptr, require_all_eigen_col_vector_t&lt; T_beta, T_cuts &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_x, T_beta, T_cuts&gt; stan::math::ordered_logistic_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_cuts &amp;&#160;</td>
          <td class="paramname"><em>cuts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the ordinal regression Generalized Linear Model (GLM). </p>
<p>This is equivalent to and faster than ordered_logistic_lpmf(y, x * beta, cuts).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>type of integer vector of classes. It can be either <code>std::vector&lt;int&gt;</code> or <code>int</code>. </td></tr>
    <tr><td class="paramname">T_x</td><td>type of the matrix of independent variables (features) </td></tr>
    <tr><td class="paramname">T_beta</td><td>type of the vector of weights </td></tr>
    <tr><td class="paramname">T_cuts</td><td>type of the vector of cutpoints</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>a scalar or vector of classes. If it is a scalar it will be broadcast - used for all instances. Values should be between 1 and number of classes, including endpoints. </td></tr>
    <tr><td class="paramname">x</td><td>design matrix or row vector. If it is a row vector it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
    <tr><td class="paramname">cuts</td><td>cutpoints vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If any class is not between 1 and the number of cutpoints plus 2 or if the cutpoint vector is not sorted in ascending order or any input is not finite </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../da/d4f/prim_2prob_2ordered__logistic__glm__lpmf_8hpp_source.html#l00048">48</a> of file <a class="el" href="../../da/d4f/prim_2prob_2ordered__logistic__glm__lpmf_8hpp_source.html">ordered_logistic_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga23b3433b23d80fd5d7289e4922a21060"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_cut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_loc, T_cut&gt; stan::math::ordered_logistic_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_cut &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the (natural) log probability of the integer/s given the vector of continuous location/s and specified cutpoints in an ordered logistic model. </p>
<p>Typically the continuous location will be the dot product of a vector of regression coefficients and a vector of predictors for the outcome.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propto</td><td>True if calculating up to a proportion. </td></tr>
    <tr><td class="paramname">T_y</td><td>y variable type (int or array of integers). </td></tr>
    <tr><td class="paramname">T_loc</td><td>Location type (double or vector). </td></tr>
    <tr><td class="paramname">T_cut</td><td>Cut-point type (vector or array of vectors). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Integers </td></tr>
    <tr><td class="paramname">lambda</td><td>Continuous location variables. </td></tr>
    <tr><td class="paramname">c</td><td>Positive increasing cutpoints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log probability of outcome given location and cutpoints. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the outcome is not between 1 and the number of cutpoints plus 2; if the cutpoint vector is empty; if the cutpoint vector contains a non-positive, non-finite value; or if the cutpoint vector is not sorted in ascending order. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If array y and vector lambda are different lengths. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if array y and array of vectors c are different lengths.</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000148">Deprecated:</a></b></dt><dd>use <code>ordered_logistic_lpmf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d4/d29/ordered__logistic__log_8hpp_source.html#l00041">41</a> of file <a class="el" href="../../d4/d29/ordered__logistic__log_8hpp_source.html">ordered_logistic_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae3d5dfc0ac36a7701b5fb2b616850837"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_cut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_loc, T_cut&gt; stan::math::ordered_logistic_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_cut &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000149">Deprecated:</a></b></dt><dd>use <code>ordered_logistic_lpmf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d4/d29/ordered__logistic__log_8hpp_source.html#l00051">51</a> of file <a class="el" href="../../d4/d29/ordered__logistic__log_8hpp_source.html">ordered_logistic_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gab0b2bd081aa551947d0b5c96d3928d92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_cut , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_cut &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_loc, T_cut&gt; stan::math::ordered_logistic_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_cut &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the (natural) log probability of the specified array of integers given the vector of continuous locations and specified cutpoints in an ordered logistic model. </p>
<p>Typically the continuous location will be the dot product of a vector of regression coefficients and a vector of predictors for the outcome</p>
<p class="formulaDsp">
\[ \frac{\partial }{\partial \lambda} = \begin{cases}\\ -\mathrm{logit}^{-1}(\lambda - c_1) &amp; \mbox{if } k = 1,\\ -(((1-e^{c_{k-1}-c_{k-2}})^{-1} - \mathrm{logit}^{-1}(c_{k-2}-\lambda)) + ((1-e^{c_{k-2}-c_{k-1}})^{-1} - \mathrm{logit}^{-1}(c_{k-1}-\lambda))) &amp; \mathrm{if } 1 &lt; k &lt; K, \mathrm{and}\\ \mathrm{logit}^{-1}(c_{K-2}-\lambda) &amp; \mathrm{if } k = K. \end{cases} \]
</p>
<p class="formulaDsp">
\[ \frac{\partial }{\partial \lambda} = \begin{cases} -\mathrm{logit}^{-1}(\lambda - c_1) &amp; \text{if } k = 1,\\ -(((1-e^{c_{k-1}-c_{k-2}})^{-1} - \mathrm{logit}^{-1}(c_{k-2}-\lambda)) + ((1-e^{c_{k-2}-c_{k-1}})^{-1} - \mathrm{logit}^{-1}(c_{k-1}-\lambda))) &amp; \text{if } 1 &lt; k &lt; K, \text{ and}\\ \mathrm{logit}^{-1}(c_{K-2}-\lambda) &amp; \text{if } k = K. \end{cases} \]
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propto</td><td>True if calculating up to a proportion. </td></tr>
    <tr><td class="paramname">T_y</td><td>Y variable type (integer or array of integers). </td></tr>
    <tr><td class="paramname">T_loc</td><td>Location type. </td></tr>
    <tr><td class="paramname">T_cut</td><td>Cut-point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array of integers </td></tr>
    <tr><td class="paramname">lambda</td><td>Vector of continuous location variables. </td></tr>
    <tr><td class="paramname">c</td><td>Positive increasing vector of cutpoints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log probability of outcome given location and cutpoints. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the outcome is not between 1 and the number of cutpoints plus 2; if the cutpoint vector is empty; if the cutpoint vector contains a non-positive, non-finite value; or if the cutpoint vector is not sorted in ascending order. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If y and lambda are different lengths. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/da5/prim_2prob_2ordered__logistic__lpmf_8hpp_source.html#l00074">74</a> of file <a class="el" href="../../dd/da5/prim_2prob_2ordered__logistic__lpmf_8hpp_source.html">ordered_logistic_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga56dd2feeb184d8ec2b6b62eabfe237f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_cut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_loc, T_cut&gt; stan::math::ordered_probit_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_cut &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the (natural) log probability of the integer/s given the vector of continuous location/s and specified cutpoints in an ordered probit model. </p>
<p>Typically the continuous location will be the dot product of a vector of regression coefficients and a vector of predictors for the outcome.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propto</td><td>True if calculating up to a proportion. </td></tr>
    <tr><td class="paramname">T_y</td><td>y variable type (int or array of integers). </td></tr>
    <tr><td class="paramname">T_loc</td><td>Location type (double or vector). </td></tr>
    <tr><td class="paramname">T_cut</td><td>Cut-point type (vector or array of vectors). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Integers </td></tr>
    <tr><td class="paramname">lambda</td><td>Continuous location variables. </td></tr>
    <tr><td class="paramname">c</td><td>Positive increasing cutpoints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log probability of outcome given location and cutpoints. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the outcome is not between 1 and the number of cutpoints plus 2; if the cutpoint vector is empty; if the cutpoint vector contains a non-positive, non-finite value; or if the cutpoint vector is not sorted in ascending order. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If array y and vector lambda are different lengths. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if array y and array of vectors c are different lengths.</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000150">Deprecated:</a></b></dt><dd>use <code>ordered_probit_lpmf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d25/ordered__probit__log_8hpp_source.html#l00041">41</a> of file <a class="el" href="../../dd/d25/ordered__probit__log_8hpp_source.html">ordered_probit_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gadf76d0e635a7190c1a13da2b3ddbd468"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_cut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_loc, T_cut&gt; stan::math::ordered_probit_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_cut &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000151">Deprecated:</a></b></dt><dd>use <code>ordered_probit_lpmf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d25/ordered__probit__log_8hpp_source.html#l00051">51</a> of file <a class="el" href="../../dd/d25/ordered__probit__log_8hpp_source.html">ordered_probit_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga44b1065be3677f5745ae216896cf59ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_cut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_loc, T_cut&gt; stan::math::ordered_probit_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_cut &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the (natural) log probability of the specified array of integers given the vector of continuous locations and array of specified cutpoints in an ordered probit model. </p>
<p>Typically the continuous location will be the dot product of a vector of regression coefficients and a vector of predictors for the outcome.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propto</td><td>True if calculating up to a proportion. </td></tr>
    <tr><td class="paramname">T_y</td><td>Type of y variable - <code>int</code> or <code>std::vector&lt;int&gt;</code>. </td></tr>
    <tr><td class="paramname">T_loc</td><td>Location type - <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vector or scalar. </td></tr>
    <tr><td class="paramname">T_cut</td><td>Cut-point type - <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vector or a std vector of <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>integer or Array of integers </td></tr>
    <tr><td class="paramname">lambda</td><td>Location. </td></tr>
    <tr><td class="paramname">c</td><td>Positive increasing vectors of cutpoints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log probability of outcome given location and cutpoints. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the outcome is not between 1 and the number of cutpoints plus 2; if the cutpoint vector contains a non-positive or non-finite value; or if the cutpoint vector is not sorted in ascending order. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If y and lambda are different lengths; if the cutpoint vector is empty; if y and the array of cutpoints are of different lengths. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dc/d6d/ordered__probit__lpmf_8hpp_source.html#l00048">48</a> of file <a class="el" href="../../dc/d6d/ordered__probit__lpmf_8hpp_source.html">ordered_probit_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4ec719b8f6c82108959c6c8668ef4027"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_x, T_alpha, T_beta&gt; stan::math::poisson_log_glm_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000168">Deprecated:</a></b></dt><dd>use <code>poisson_logit_glm_lpmf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d4/d8d/poisson__log__glm__log_8hpp_source.html#l00015">15</a> of file <a class="el" href="../../d4/d8d/poisson__log__glm__log_8hpp_source.html">poisson_log_glm_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9c49cb4ea519606e1432989b0ddaef9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_x, T_alpha, T_beta&gt; stan::math::poisson_log_glm_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000169">Deprecated:</a></b></dt><dd>use <code>poisson_logit_glm_lpmf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d4/d8d/poisson__log__glm__log_8hpp_source.html#l00027">27</a> of file <a class="el" href="../../d4/d8d/poisson__log__glm__log_8hpp_source.html">poisson_log_glm_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gabdac9b18cd635354f25b6a4208b4ccbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , require_eigen_t&lt; T_x &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_x, T_alpha, T_beta&gt; stan::math::poisson_log_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the Generalized Linear Model (GLM) with Poisson distribution and log link function. </p>
<p>The idea is that poisson_log_glm_lpmf(y, x, alpha, beta) should compute a more efficient version of poisson_log_lpmf(y, alpha + x * beta) by using analytically simplified gradients. If containers are supplied, returns the log sum of the probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>type of vector of variates (labels), integers &gt;=0; this can also be a single positive integer; </td></tr>
    <tr><td class="paramname">T_x</td><td>type the matrix of independent variables (features) </td></tr>
    <tr><td class="paramname">T_x_rows</td><td>compile-time number of rows of <code>x</code>. It can be either <code>Eigen::Dynamic</code> or 1. </td></tr>
    <tr><td class="paramname">T_alpha</td><td>type of the intercept(s); this can be a vector (of the same length as y) of intercepts or a single value (for models with constant intercept); </td></tr>
    <tr><td class="paramname">T_beta</td><td>type of the weight vector; this can also be a single value; </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>positive integer scalar or vector parameter. If it is a scalar it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">x</td><td>design matrix or row vector. If it is a row vector it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if x, beta or alpha is infinite. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is negative. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/dd2/prim_2prob_2poisson__log__glm__lpmf_8hpp_source.html#l00052">52</a> of file <a class="el" href="../../d3/dd2/prim_2prob_2poisson__log__glm__lpmf_8hpp_source.html">poisson_log_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga87c0dd922ca1264e0a9edf696b1c1df5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_dof , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_dof, T_scale&gt; stan::math::wishart_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the Wishart density for the given W, degrees of freedom, and scale matrix. </p>
<p>The scale matrix, S, must be k x k, symmetric, and semi-positive definite. Dimension, k, is implicit. nu must be greater than k-1</p>
<p class="formulaDsp">
\begin{eqnarray*} W &amp;\sim&amp; \mbox{\sf{Wishart}}_{\nu} (S) \\ \log (p (W \, |\, \nu, S) ) &amp;=&amp; \log \left( \left(2^{\nu k/2} \pi^{k (k-1) /4} \prod_{i=1}^k{\Gamma (\frac{\nu + 1 - i}{2})} \right)^{-1} \times \left| S \right|^{-\nu/2} \left| W \right|^{(\nu - k - 1) / 2} \times \exp (-\frac{1}{2} \mbox{tr} (S^{-1} W)) \right) \\ &amp;=&amp; -\frac{\nu k}{2}\log(2) - \frac{k (k-1)}{4} \log(\pi) - \sum_{i=1}^{k}{\log (\Gamma (\frac{\nu+1-i}{2}))} -\frac{\nu}{2} \log(\det(S)) + \frac{\nu-k-1}{2}\log (\det(W)) - \frac{1}{2} \mbox{tr} (S^{-1}W) \end{eqnarray*}
</p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000208">Deprecated:</a></b></dt><dd>use <code>wishart_lpdf</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">W</td><td>A scalar matrix </td></tr>
    <tr><td class="paramname">nu</td><td>Degrees of freedom </td></tr>
    <tr><td class="paramname">S</td><td>The scale matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the Wishart density at W given nu and S. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than k-1 </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if S is not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of matrix. </td></tr>
    <tr><td class="paramname">T_dof</td><td>Type of degrees of freedom. </td></tr>
    <tr><td class="paramname">T_scale</td><td>Type of scale. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d6/d0f/wishart__log_8hpp_source.html#l00044">44</a> of file <a class="el" href="../../d6/d0f/wishart__log_8hpp_source.html">wishart_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gabb976f445cd5d31069393ee76d763d14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_dof, T_scale&gt; stan::math::wishart_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000209">Deprecated:</a></b></dt><dd>use <code>wishart_lpdf</code> </dd></dl>

<p>Definition at line <a class="el" href="../../d6/d0f/wishart__log_8hpp_source.html#l00053">53</a> of file <a class="el" href="../../d6/d0f/wishart__log_8hpp_source.html">wishart_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gad2ed3c31ff75e645d1b12662685a9492"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_dof , typename T_scale , require_stan_scalar_t&lt; T_dof &gt; *  = nullptr, require_all_matrix_t&lt; T_y, T_scale &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y, T_dof, T_scale&gt; stan::math::wishart_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the Wishart density for the given W, degrees of freedom, and scale matrix. </p>
<p>The scale matrix, S, must be k x k, symmetric, and semi-positive definite. Dimension, k, is implicit. nu must be greater than k-1</p>
<p class="formulaDsp">
\begin{eqnarray*} W &amp;\sim&amp; \mbox{\sf{Wishart}}_{\nu} (S) \\ \log (p (W \, |\, \nu, S) ) &amp;=&amp; \log \left( \left(2^{\nu k/2} \pi^{k (k-1) /4} \prod_{i=1}^k{\Gamma (\frac{\nu + 1 - i}{2})} \right)^{-1} \times \left| S \right|^{-\nu/2} \left| W \right|^{(\nu - k - 1) / 2} \times \exp (-\frac{1}{2} \mbox{tr} (S^{-1} W)) \right) \\ &amp;=&amp; -\frac{\nu k}{2}\log(2) - \frac{k (k-1)}{4} \log(\pi) - \sum_{i=1}^{k}{\log (\Gamma (\frac{\nu+1-i}{2}))} -\frac{\nu}{2} \log(\det(S)) + \frac{\nu-k-1}{2}\log (\det(W)) - \frac{1}{2} \mbox{tr} (S^{-1}W) \end{eqnarray*}
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>type of matrix </td></tr>
    <tr><td class="paramname">T_dof</td><td>type of degrees of freedom </td></tr>
    <tr><td class="paramname">T_scale</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">W</td><td>A scalar matrix </td></tr>
    <tr><td class="paramname">nu</td><td>Degrees of freedom </td></tr>
    <tr><td class="paramname">S</td><td>The scale matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the Wishart density at W given nu and S. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than k-1 </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if S is not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../df/d6d/wishart__lpdf_8hpp_source.html#l00049">49</a> of file <a class="el" href="../../df/d6d/wishart__lpdf_8hpp_source.html">wishart_lpdf.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
