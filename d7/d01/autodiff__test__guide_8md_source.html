<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: doxygen/contributor_help_pages/autodiff_test_guide.md Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../$standoxy.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">4.0.1</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d7/d01/autodiff__test__guide_8md.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">doxygen/contributor_help_pages/autodiff_test_guide.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="../../d7/d01/autodiff__test__guide_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Automatic Differentiation Testing Guide {#autodiff_test_guide}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;The automatic differentiation testing framework tests the value and derivatives (up to third order) of a function against results derived from the primitive implementation with finite differences.  Multivariate functions are tested as unary functions by projecting to each output dimension.  All that needs to be provided is a working primitive implementation and the inputs to test.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;Derivatives are tested</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;* with user supplied arguments plus all combinations of automatic differentiation variables up to third order:</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    - first order: `var` (gradient), `fvar&lt;double&gt;` tested using `gradient()` functionals</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    - second order: `fvar&lt;var&gt;`, `fvar&lt;fvar&lt;double&gt;&gt;` tested using `hessian()` functionals</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    - third order: `fvar&lt;fvar&lt;var&gt;&gt;` tested using `grad_hessian()` functional</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;* for all possible output values for functions with multivariate outputs,</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;* for all possible combinations of argument instantiations with primitive (`int` or `double`) and automatic differentiation variables, and</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;* up to three levels of container nesting for elementwise vectorized functions.</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;Exceptions are tested insofar as if one version of the primitive or autodiff versions of the function throws an exception they must all throw an exception  That is, each autodiff call must throw exceptions for exactly the same argument values as the primitive implementation.</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;### Scope of tests</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;The framework can test unary and binary functions with any of the following input and output types.  </div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;The basic types that can be handled by the testing framework are</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;* `int`: integer</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;* `double`: double-precision floating point</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;* `Eigen::Matrix&lt;double, -1, 1&gt;`: column vector</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;* `Eigen::Matrix&lt;double, 1, -1&gt;`: row vector</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;* `Eigen::Matrix&lt;double, -1, -1&gt;`: matrix</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;For any type `T` that can be handled, the framework can also handle the corresponding standard vector type (used for arrays in Stan)</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;* `std::vector&lt;T&gt;`: array of elements of type `T`</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;### Relative error comparisons</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;The tests are instrumented to test relative error between the values and derivatives produced by the function being tested and those produced by finite differences.  For non-zero inputs, the relative error is defined to be the error divided by the average absolute values of the arguments:</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;```cpp</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;error(u, v) = u - v</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;relative_error(u, v) = error(u, v) / (0.5 * (abs(u) + abs(v)))</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;```</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;If one of the inputs is zero, error is used rather than relative error (because relative error devolves if one or both inputs are zero)</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;### Tests and tolerances</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;The following table lists the complete set of tests, with their default tolerances, the type of automatic differentiation variable used, the name of the functional used to perform the test, and the order of the test.  The first column lists the names of the member variables in the simple struct `stan::test::ad_tolerances`.  Every test accepts an `ad_tolerances` object as a first argument, so the defaults may be overridden for particular tests.   The default tolerances are set relatively high because of the inaccuracy of simple finite difference calculations as used by these tests.  </div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;| function                     | tolerance |  autodiff type       | functional     | (order) test            |</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;|-----------------------------:|:---------:|:--------------------:|:--------------:|:------------------------|</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;| `gradient_val_`              | 1e-8      | `var`                | `gradient`     | (0) value               |</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;| `gradient_grad_`             | 1e-4      | `var`                | `gradient`     | (1) gradient            |</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;| `gradient_fvar_val_`         | 1e-8      | `fvar&lt;double&gt;`       | `gradient`     | (0) value               |</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;| `gradient_fvar_grad_`        | 1e-4      | `fvar&lt;double&gt;`       | `gradient`     | (1) gradient            |</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;| `hessian_val_`               | 1e-8      | `fvar&lt;var&gt;`          | `hessian`      | (0) value               |</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;| `hessian_grad_`              | 1e-4      | `fvar&lt;var&gt;`          | `hessian`      | (1) gradient            |</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;| `hessian_hessian_`           | 1e-3      | `fvar&lt;var&gt;`          | `hessian`      | (2) Hessian             |</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;| `hessian_fvar_val_`          | 1e-8      | `fvar&lt;fvar&lt;double&gt;&gt;` | `hessian`      | (0) value               |</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;| `hessian_fvar_grad_`         | 1e-4      | `fvar&lt;fvar&lt;double&gt;&gt;` | `hessian`      | (1) gradient            |</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;| `hessian_fvar_hessian_`      | 1e-3      | `fvar&lt;fvar&lt;double&gt;&gt;` | `hessian`      | (2) Hessian             |</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;| `grad_hessian_val_`          | 1e-8      | `fvar&lt;fvar&lt;var&gt;&gt;`    | `grad_hessian` | (0) value               |</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;| `grad_hessian_hessian_`      | 1e-3      | `fvar&lt;fvar&lt;var&gt;&gt;`    | `grad_hessian` | (2) Hessian             |</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;| `grad_hessian_grad_hessian_` | 1e-2      | `fvar&lt;fvar&lt;var&gt;&gt;`    | `grad_hessian` | (3) gradient of Hessian |</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;### Examples</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;These examples are all included in the unit tests for the test framework in file `test/unit/math/test_ad_test.cpp`</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;#### Example: matrix inverse (unary function)</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;Let&#39;s start by seeing how to test matrix inverse.  In Stan, that&#39;s a unary function `inverse` that takes a matrix input and returns a matrix output.</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;```cpp</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;Matrix&lt;T, -1, -1&gt; inverse(const Matrix&lt;T, -1, 1&gt;&amp; a);</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;```</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;We&#39;ll need to include the test framework (which includes both the Google test framework and all of the Stan math library (by including `&lt;stan/math.hpp&gt;).  The entire library is included to ensure that all functions work under the standard include system when all higher-order autodiff is included.</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;Each test is scoped within a Google test framework `TEST` macro.  Thus all of our test files will look like this:</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;```cpp</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;#include &lt;test/unit/math/test_ad.hpp&gt;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;TEST(test_name, subtest1_name) {</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  ... first test goes here...</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;}</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;TEST(test_name, subtest2_name) {</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  ... second test goes here...</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;}</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;... more tests may follow ...</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;```</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;If there is more than one test, there will be more than one `TEST` macro invocation, each with a unique combination of test name and subtest name.</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;The body of a test will define a polymorphic functor to test, then a sequence of arguments to test with thest framework.  Although a functor is necessary in order for there to be a single type encapsulating all possible overloads, it can be a simple closure.</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;Here&#39;s what the first test looks like for `inverse`, repeating the macro wrapper and include</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;```cpp</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;#include &lt;test/unit/math/test_ad.hpp&gt;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;TEST(inverse, two_by_two) {</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;  auto inverse_functor = [](const auto&amp; u) {</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    return stan::math::inverse(u);</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  };</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  Eigen::MatrixXd x(2, 2);</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  x &lt;&lt; 1.9, 0.3,</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;       0.3, 1.7;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  stan::test::expect_ad(inverse_functor, x);</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;}</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;```</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;That&#39;s it.  The `inverse_functor` is defined using a lambda (with no closure --- the `[ ]` bit) taking a `const auto&amp;` argument and returning the result of applying `stan::math::inverse`.  Generic lambdas are a C++14 feature (in `-std=c++1y` for the compiler).  They&#39;re convenient here because they define a polymorphic functor defined for any argument for which the body is defined, which here means any argument `u` for which `stan::math::inverse(u)` is defined.  Bare functions aren&#39;t enough for the testing framework functions like `expect_ad` to perform type inference as they do not have a single type.  The functor defined by the lambda closure has a single type.</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;The second bit of the code defines the Matrix to test, here an invertible positive-definite matrix with first row `[1.9  0.3]` and second row `[0.3  1.9]`.  </div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;The final bit of the code simply invokes the test framework for the functor and argument(s) being tested.  The `expect_ad` function is both variadic and overloaded to deal with arbitrary Stan-relevant input and output types.  </div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;#### Example 1a: Adding tolerances</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;If we wanted to lower the tolerance for the gradient test using reverse-mode autodiff, we could use</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;```cpp</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;ad_tolerances tols;  // constructed with default tolerances</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;tols.gradient_grad_ = 1e-3;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;expect_ad(tols, inverse_functor, x);</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;```</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;#### Example 2: Binary Function (multiply matrix/scalar)</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;Binary functions are handled the same way as unary functions.  The framework tests all combinations of input autodiff types, e.g., `f(double, var)`, `f(var, double)`, and `f(var, var)` for testing reverse-mode instantiations.  When there is more than one autodiff variable argument, all autodiff arguments must be of the same type.  </div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;```cpp</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;#include &lt;test/unit/math/test_ad.hpp&gt;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;TEST(multiply_matrix_scalar, test1) {</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;  auto g = [ ] (const auto&amp; u, const auto&amp; v) {</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    return stan::math::multiply(u, v);</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  };</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  Eigen::MatrixXd x(2, 3);</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  x &lt;&lt; 1, 2, 3, 4, 5, 6;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;  double y = -3;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  stan::test::expect_ad(g, x, y);</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;  double y2 = std::numeric_limits&lt;double&gt;::quiet_NaN();</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  stan::test::expect_ad(g, x, y2);</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;}</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;```</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;The lambda here abstracts two arguments to which it applies the `multiply` function.  There are two tests.  Here The first takes `y = -3` and the second `y = NaN`.  </div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;#### Example 3: vectorized unary scalar function</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;Most of the unary scalar functions in Stan are vectorized in that they can be applied elementwise to any container type.</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;The only difference in calls is that the `expect_ad_vectorized` function is used in place of `expect_ad`.  The `log10` function is vectorized to operate elementwise, and the following code will test it.</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;```cpp</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;#include &lt;test/unit/math/test_ad.hpp&gt;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;TEST(test_unit_math_test_ad, expect_ad_vectorized) {</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  auto g = [ ] (const auto&amp; u) {</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    return stan::math::log10(u);</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  };</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  stan::test::expect_ad_vectorized(g, 3.2);  // finite return</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  stan::test::expect_ad_vectorized(g, 0);  // infinite return</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  stan::test::expect_ad_vectorized(g, -1.7);  // NaN return</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;}</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;```</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;#### Example 4: Mismatched autodiff and double functions</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;The following function has an autodiff implementation that differs by a negation from the primitive version, throwing off value and derivative tests.</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;```cpp</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;#include &lt;test/unit/math/test_ad.hpp&gt;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;TEST(test_ad, mismatch) {</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;  double x = 3.2;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;  auto g = [](const auto&amp; u) { return f_mismatch(u); };</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  // include following line to show exception error behavior</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  stan::test::expect_ad(g, x);</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;}</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;```</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;```cpp</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;~/cmdstan/stan/lib/stan_math$ ./runTests.py -j4 test/unit/math/test_ad_test.cpp</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;...</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;[ RUN      ] test_ad.mismatch</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;./test/unit/math/mix/mat/util/autodiff_tester.hpp:75: Failure</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;The difference between x1 and x2 is 12.800000000000001, which exceeds tol, where</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;x1 evaluates to -6.4000000000000004,</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;x2 evaluates to 6.4000000000000004, and</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;tol evaluates to 1.0000000000000001e-09.</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;expect_near(-6.4000000000000004, 6.4000000000000004)</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;test_gradient fx = fx_ad</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;./test/unit/math/mix/mat/util/autodiff_tester.hpp:75: Failure</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;The difference between x1 and x2 is 4.0000000000000764, which exceeds tol, where</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;x1 evaluates to -2.0000000000000759,</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;x2 evaluates to 2, and</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;tol evaluates to 9.9999999999999995e-08.</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;expect_near(-2.0000000000000759, 2)</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;expect_near elt x1(i) = x2(i)</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;test gradient grad_fd == grad_ad</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;[  FAILED  ] test_ad.mismatch (1 ms)</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;```</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;#### Example 5: Mismatched Exceptions</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;```cpp</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;#include &lt;test/unit/math/test_ad.hpp&gt;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;template &lt;typename T&gt;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;T f_misthrow(const T&amp; x) {</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;  return -2 * x;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;}</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;double f_misthrow(const double&amp; x) {</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;  throw std::runtime_error(&quot;f_misthrow(double) called&quot;);</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;  return -2 * x;</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;}</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;TEST(test_ad, misthrow) {</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;  double x = 1.73;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;  auto h = [](const auto&amp; u) { return f_misthrow(u); };</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;  stan::test::expect_ad(h, x);</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;}</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;```</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;Uncommenting the test above in the test file and running produces the exception diagnostic:</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;```cpp</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;~/cmdstan/stan/lib/stan_math$ ./runTests.py -j4 test/unit/math/test_ad_test.cpp</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;[ RUN      ] test_ad.misthrow</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;./test/unit/math/mix/mat/util/autodiff_tester.hpp:234: Failure</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;Failed</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;double throws, expect autodiff version to throw</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;./test/unit/math/mix/mat/util/autodiff_tester.hpp:234: Failure</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;Failed</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;double throws, expect autodiff version to throw</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;./test/unit/math/mix/mat/util/autodiff_tester.hpp:234: Failure</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;Failed</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;double throws, expect autodiff version to throw</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;./test/unit/math/mix/mat/util/autodiff_tester.hpp:234: Failure</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;Failed</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;double throws, expect autodiff version to throw</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;./test/unit/math/mix/mat/util/autodiff_tester.hpp:234: Failure</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;Failed</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;double throws, expect autodiff version to throw</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;[  FAILED  ] test_ad.misthrow (0 ms)</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;```</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d7/d01/autodiff__test__guide_8md.html">autodiff_test_guide.md</a></li>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
